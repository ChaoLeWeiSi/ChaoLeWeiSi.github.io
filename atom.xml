<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s Blog</title>
  
  <subtitle>记录并总结cs相关知识</subtitle>
  <link href="https://chaoleweisi.github.io/atom.xml" rel="self"/>
  
  <link href="https://chaoleweisi.github.io/"/>
  <updated>2024-10-14T06:35:56.803Z</updated>
  <id>https://chaoleweisi.github.io/</id>
  
  <author>
    <name>侏小一</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图的小结</title>
    <link href="https://chaoleweisi.github.io/posts/7c4aa217/"/>
    <id>https://chaoleweisi.github.io/posts/7c4aa217/</id>
    <published>2024-10-13T07:11:14.000Z</published>
    <updated>2024-10-14T06:35:56.803Z</updated>
    
    <content type="html"><![CDATA[<h1>小结</h1><h3 id="重点回顾">重点回顾</h3><ul><li>图由顶点和边组成，可以表示为一组顶点和一组边构成的集合。</li><li>相较于线性关系（链表）和分治关系（树），网络关系（图）具有更高的自由度，因而更为复杂。</li><li>有向图的边具有方向性，连通图中的任意顶点均可达，有权图的每条边都包含权重变量。</li><li>邻接矩阵利用矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 表示两个顶点之间有边或无边。邻接矩阵在增删查改操作上效率很高，但空间占用较多。</li><li>邻接表使用多个链表来表示图，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个链表对应顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，其中存储了该顶点的所有邻接顶点。邻接表相对于邻接矩阵更加节省空间，但由于需要遍历链表来查找边，因此时间效率较低。</li><li>当邻接表中的链表过长时，可以将其转换为红黑树或哈希表，从而提升查询效率。</li><li>从算法思想的角度分析，邻接矩阵体现了“以空间换时间”，邻接表体现了“以时间换空间”。</li><li>图可用于建模各类现实系统，如社交网络、地铁线路等。</li><li>树是图的一种特例，树的遍历也是图的遍历的一种特例。</li><li>图的广度优先遍历是一种由近及远、层层扩张的搜索方式，通常借助队列实现。</li><li>图的深度优先遍历是一种优先走到底、无路可走时再回溯的搜索方式，常基于递归来实现。</li></ul><h3 id="Q-A">Q &amp; A</h3><p><strong>Q</strong>：路径的定义是顶点序列还是边序列？</p><p>维基百科上不同语言版本的定义不一致：英文版是“路径是一个边序列”，而中文版是“路径是一个顶点序列”。以下是英文版原文：In graph theory, a path in a graph is a finite or infinite sequence of edges which joins a sequence of vertices.</p><p>在本文中，路径被视为一个边序列，而不是一个顶点序列。这是因为两个顶点之间可能存在多条边连接，此时每条边都对应一条路径。</p><p><strong>Q</strong>：非连通图中是否会有无法遍历到的点？</p><p>在非连通图中，从某个顶点出发，至少有一个顶点无法到达。遍历非连通图需要设置多个起点，以遍历到图的所有连通分量。</p><p><strong>Q</strong>：在邻接表中，“与该顶点相连的所有顶点”的顶点顺序是否有要求？</p><p>可以是任意顺序。但在实际应用中，可能需要按照指定规则来排序，比如按照顶点添加的次序，或者按照顶点值大小的顺序等，这样有助于快速查找“带有某种极值”的顶点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;小结&lt;/h1&gt;
&lt;h3 id=&quot;重点回顾&quot;&gt;重点回顾&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;图由顶点和边组成，可以表示为一组顶点和一组边构成的集合。&lt;/li&gt;
&lt;li&gt;相较于线性关系（链表）和分治关系（树），网络关系（图）具有更高的自由度，因而更为复杂。&lt;/li&gt;
&lt;li&gt;有向图的</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="图" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
    <category term="图" scheme="https://chaoleweisi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图的遍历</title>
    <link href="https://chaoleweisi.github.io/posts/f1a8c9e2/"/>
    <id>https://chaoleweisi.github.io/posts/f1a8c9e2/</id>
    <published>2024-10-13T07:01:14.000Z</published>
    <updated>2024-10-14T06:35:49.693Z</updated>
    
    <content type="html"><![CDATA[<h1>图的遍历</h1><p>树代表的是“一对多”的关系，而图则具有更高的自由度，可以表示任意的“多对多”关系。因此，我们可以把树看作图的一种特例。显然，<strong>树的遍历操作也是图的遍历操作的一种特例</strong>。</p><p>图和树都需要应用搜索算法来实现遍历操作。图的遍历方式也可分为两种：<u>广度优先遍历</u>和<u>深度优先遍历</u>。</p><h2 id="广度优先遍历">广度优先遍历</h2><p><strong>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张</strong>。如下图所示，从左上角顶点出发，首先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻接顶点，以此类推，直至所有顶点访问完毕。</p><p><img src="/posts/f1a8c9e2/graph_bfs.png" alt="图的广度优先遍历"></p><h3 id="算法实现">算法实现</h3><p>BFS 通常借助队列来实现，代码如下所示。队列具有“先入先出”的性质，这与 BFS 的“由近及远”的思想异曲同工。</p><ol><li>将遍历起始顶点 <code>startVet</code> 加入队列，并开启循环。</li><li>在循环的每轮迭代中，弹出队首顶点并记录访问，然后将该顶点的所有邻接顶点加入到队列尾部。</li><li>循环步骤 <code>2.</code> ，直到所有顶点被访问完毕后结束。</li></ol><p>为了防止重复遍历顶点，我们需要借助一个哈希集合 <code>visited</code> 来记录哪些节点已被访问。</p><pre><code>哈希集合可以看作一个只存储 `key` 而不存储 `value` 的哈希表，它可以在 $O(1)$ 时间复杂度下进行 `key` 的增删查改操作。根据 `key` 的唯一性，哈希集合通常用于数据去重等场景。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">graph_bfs</span>(<span class="params">graph: GraphAdjList, start_vet: Vertex</span>) -&gt; <span class="built_in">list</span>[Vertex]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;广度优先遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">    <span class="comment"># 顶点遍历序列</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 哈希集合，用于记录已被访问过的顶点</span></span><br><span class="line">    visited = <span class="built_in">set</span>[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 队列用于实现 BFS</span></span><br><span class="line">    que = deque[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(que) &gt; <span class="number">0</span>:</span><br><span class="line">        vet = que.popleft()  <span class="comment"># 队首顶点出队</span></span><br><span class="line">        res.append(vet)  <span class="comment"># 记录访问顶点</span></span><br><span class="line">        <span class="comment"># 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> adj_vet <span class="keyword">in</span> graph.adj_list[vet]:</span><br><span class="line">            <span class="keyword">if</span> adj_vet <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 跳过已被访问的顶点</span></span><br><span class="line">            que.append(adj_vet)  <span class="comment"># 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adj_vet)  <span class="comment"># 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment"># 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>代码相对抽象，建议对照下图来加深理解。<br><strong>图的广度优先遍历步骤</strong></p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">bfs 1</button><button type="button" class="tab">bfs 2</button><button type="button" class="tab">bfs 3</button><button type="button" class="tab">bfs 4</button><button type="button" class="tab">bfs 5</button><button type="button" class="tab">bfs 6</button><button type="button" class="tab">bfs 7</button><button type="button" class="tab">bfs 8</button><button type="button" class="tab">bfs 9</button><button type="button" class="tab">bfs 10</button><button type="button" class="tab">bfs 11</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/f1a8c9e2/graph_bfs_step1.png" alt="图的广度优先遍历步骤"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step2.png" alt="graph_bfs_step2"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step3.png" alt="graph_bfs_step3"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step4.png" alt="graph_bfs_step4"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step5.png" alt="graph_bfs_step5"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step6.png" alt="graph_bfs_step6"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step7.png" alt="graph_bfs_step7"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step8.png" alt="graph_bfs_step8"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step9.png" alt="graph_bfs_step9"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step10.png" alt="graph_bfs_step10"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_bfs_step11.png" alt="graph_bfs_step11"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning simple"><p>question “广度优先遍历的序列是否唯一？”</p></div><pre><code>不唯一。广度优先遍历只要求按“由近及远”的顺序遍历，**而多个相同距离的顶点的遍历顺序允许被任意打乱**。以上图为例，顶点 $1$、$3$ 的访问顺序可以交换，顶点 $2$、$4$、$6$ 的访问顺序也可以任意交换。</code></pre><h3 id="复杂度分析">复杂度分析</h3><p><strong>时间复杂度</strong>：所有顶点都会入队并出队一次，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 时间；在遍历邻接顶点的过程中，由于是无向图，因此所有边都会被访问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 次，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 时间；总体使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V| + |E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 时间。</p><p><strong>空间复杂度</strong>：列表 <code>res</code> ，哈希集合 <code>visited</code> ，队列 <code>que</code> 中的顶点数量最多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span></span></span></span> ，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 空间。</p><h2 id="深度优先遍历">深度优先遍历</h2><p><strong>深度优先遍历是一种优先走到底、无路可走再回头的遍历方式</strong>。如下图所示，从左上角顶点出发，访问当前顶点的某个邻接顶点，直到走到尽头时返回，再继续走到尽头并返回，以此类推，直至所有顶点遍历完成。</p><p><img src="/posts/f1a8c9e2/graph_dfs.png" alt="图的深度优先遍历"></p><h3 id="算法实现-2">算法实现</h3><p>这种“走到尽头再返回”的算法范式通常基于递归来实现。与广度优先遍历类似，在深度优先遍历中，我们也需要借助一个哈希集合 <code>visited</code> 来记录已被访问的顶点，以避免重复访问顶点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph: GraphAdjList, visited: <span class="built_in">set</span>[Vertex], res: <span class="built_in">list</span>[Vertex], vet: Vertex</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;深度优先遍历辅助函数&quot;&quot;&quot;</span></span><br><span class="line">    res.append(vet)  <span class="comment"># 记录访问顶点</span></span><br><span class="line">    visited.add(vet)  <span class="comment"># 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment"># 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> adjVet <span class="keyword">in</span> graph.adj_list[vet]:</span><br><span class="line">        <span class="keyword">if</span> adjVet <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment"># 跳过已被访问的顶点</span></span><br><span class="line">        <span class="comment"># 递归访问邻接顶点</span></span><br><span class="line">        dfs(graph, visited, res, adjVet)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">graph_dfs</span>(<span class="params">graph: GraphAdjList, start_vet: Vertex</span>) -&gt; <span class="built_in">list</span>[Vertex]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;深度优先遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">    <span class="comment"># 顶点遍历序列</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 哈希集合，用于记录已被访问过的顶点</span></span><br><span class="line">    visited = <span class="built_in">set</span>[Vertex]()</span><br><span class="line">    dfs(graph, visited, res, start_vet)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>深度优先遍历的算法流程如下图所示。</p><ul><li><strong>直虚线代表向下递推</strong>，表示开启了一个新的递归方法来访问新顶点。</li><li><strong>曲虚线代表向上回溯</strong>，表示此递归方法已经返回，回溯到了开启此方法的位置。</li></ul><p>为了加深理解，建议将下图与代码结合起来，在脑中模拟（或者用笔画下来）整个 DFS 过程，包括每个递归方法何时开启、何时返回。</p><p><strong>图的深度优先遍历步骤</strong></p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">dfs 1</button><button type="button" class="tab">dfs 2</button><button type="button" class="tab">dfs 3</button><button type="button" class="tab">dfs 4</button><button type="button" class="tab">dfs 5</button><button type="button" class="tab">dfs 6</button><button type="button" class="tab">dfs 7</button><button type="button" class="tab">dfs 8</button><button type="button" class="tab">dfs 9</button><button type="button" class="tab">dfs 10</button><button type="button" class="tab">dfs 11</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/f1a8c9e2/graph_dfs_step1.png" alt="图的深度优先遍历步骤"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step2.png" alt="graph_dfs_step2"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step3.png" alt="graph_dfs_step3"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step4.png" alt="graph_dfs_step4"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step5.png" alt="graph_dfs_step5"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step6.png" alt="graph_dfs_step6"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step7.png" alt="graph_dfs_step7"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step8.png" alt="graph_dfs_step8"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step9.png" alt="graph_dfs_step9"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step10.png" alt="graph_dfs_step10"></p></div><div class="tab-item-content"><p><img src="/posts/f1a8c9e2/graph_dfs_step11.png" alt="graph_dfs_step11"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note simple"><p>question “深度优先遍历的序列是否唯一？”</p></div><pre><code>与广度优先遍历类似，深度优先遍历序列的顺序也不是唯一的。给定某顶点，先往哪个方向探索都可以，即邻接顶点的顺序可以任意打乱，都是深度优先遍历。以树的遍历为例，“根 $\rightarrow$ 左 $\rightarrow$ 右”“左 $\rightarrow$ 根 $\rightarrow$ 右”“左 $\rightarrow$ 右 $\rightarrow$ 根”分别对应前序、中序、后序遍历，它们展示了三种遍历优先级，然而这三者都属于深度优先遍历。</code></pre><h3 id="复杂度分析-2">复杂度分析</h3><p><strong>时间复杂度</strong>：所有顶点都会被访问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 次，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 时间；所有边都会被访问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 次，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 时间；总体使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V| + |E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 时间。</p><p><strong>空间复杂度</strong>：列表 <code>res</code> ，哈希集合 <code>visited</code> 顶点数量最多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span></span></span></span> ，递归深度最大为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span></span></span></span> ，因此使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|V|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;图的遍历&lt;/h1&gt;
&lt;p&gt;树代表的是“一对多”的关系，而图则具有更高的自由度，可以表示任意的“多对多”关系。因此，我们可以把树看作图的一种特例。显然，&lt;strong&gt;树的遍历操作也是图的遍历操作的一种特例&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;图和树都需要应用搜索算法来实现遍</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="图" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
    <category term="图" scheme="https://chaoleweisi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图的基础操作</title>
    <link href="https://chaoleweisi.github.io/posts/63f65399/"/>
    <id>https://chaoleweisi.github.io/posts/63f65399/</id>
    <published>2024-10-13T05:01:14.000Z</published>
    <updated>2024-10-14T06:35:41.746Z</updated>
    
    <content type="html"><![CDATA[<h1>图的基础操作</h1><p>图的基础操作可分为对“边”的操作和对“顶点”的操作。在“邻接矩阵”和“邻接表”两种表示方法下，实现方式有所不同。</p><h2 id="基于邻接矩阵的实现">基于邻接矩阵的实现</h2><p>给定一个顶点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的无向图，则各种操作的实现方式如下图所示。</p><ul><li><strong>添加或删除边</strong>：直接在邻接矩阵中修改指定的边即可，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间。而由于是无向图，因此需要同时更新两个方向的边。</li><li><strong>添加顶点</strong>：在邻接矩阵的尾部添加一行一列，并全部填 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 即可，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间。</li><li><strong>删除顶点</strong>：在邻接矩阵中删除一行一列。当删除首行首列时达到最差情况，需要将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(n-1)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 个元素“向左上移动”，从而使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 时间。</li><li><strong>初始化</strong>：传入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个顶点，初始化长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的顶点列表 <code>vertices</code> ，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间；初始化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 大小的邻接矩阵 <code>adjMat</code> ，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 时间。</li></ul><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">初始化邻接矩阵</button><button type="button" class="tab">添加边</button><button type="button" class="tab">删除边</button><button type="button" class="tab">添加顶点</button><button type="button" class="tab">删除顶点</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/63f65399/adjacency_matrix_step1_initialization.png" alt="邻接矩阵的初始化、增删边、增删顶点"></p></div><div class="tab-item-content"><p><img src="/posts/63f65399/adjacency_matrix_step2_add_edge.png" alt="adjacency_matrix_add_edge"></p></div><div class="tab-item-content"><p><img src="/posts/63f65399/adjacency_matrix_step3_remove_edge.png" alt="adjacency_matrix_remove_edge"></p></div><div class="tab-item-content"><p><img src="/posts/63f65399/adjacency_matrix_step4_add_vertex.png" alt="adjacency_matrix_add_vertex"></p></div><div class="tab-item-content"><p><img src="/posts/63f65399/adjacency_matrix_step5_remove_vertex.png" alt="adjacency_matrix_remove_vertex"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>以下是基于邻接矩阵表示图的实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于邻接矩阵实现的无向图类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vertices: <span class="built_in">list</span>[<span class="built_in">int</span>], edges: <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span></span><br><span class="line">        <span class="variable language_">self</span>.vertices: <span class="built_in">list</span>[<span class="built_in">int</span>] = []</span><br><span class="line">        <span class="comment"># 邻接矩阵，行列索引对应“顶点索引”</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat: <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]] = []</span><br><span class="line">        <span class="comment"># 添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vertices:</span><br><span class="line">            <span class="variable language_">self</span>.add_vertex(val)</span><br><span class="line">        <span class="comment"># 添加边</span></span><br><span class="line">        <span class="comment"># 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="variable language_">self</span>.add_edge(e[<span class="number">0</span>], e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取顶点数量&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.vertices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_vertex</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加顶点&quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="variable language_">self</span>.size()</span><br><span class="line">        <span class="comment"># 向顶点列表中添加新顶点的值</span></span><br><span class="line">        <span class="variable language_">self</span>.vertices.append(val)</span><br><span class="line">        <span class="comment"># 在邻接矩阵中添加一行</span></span><br><span class="line">        new_row = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="variable language_">self</span>.adj_mat.append(new_row)</span><br><span class="line">        <span class="comment"># 在邻接矩阵中添加一列</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="variable language_">self</span>.adj_mat:</span><br><span class="line">            row.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_vertex</span>(<span class="params">self, index: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除顶点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="variable language_">self</span>.size():</span><br><span class="line">            <span class="keyword">raise</span> IndexError()</span><br><span class="line">        <span class="comment"># 在顶点列表中移除索引 index 的顶点</span></span><br><span class="line">        <span class="variable language_">self</span>.vertices.pop(index)</span><br><span class="line">        <span class="comment"># 在邻接矩阵中删除索引 index 的行</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat.pop(index)</span><br><span class="line">        <span class="comment"># 在邻接矩阵中删除索引 index 的列</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="variable language_">self</span>.adj_mat:</span><br><span class="line">            row.pop(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_edge</span>(<span class="params">self, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加边&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">        <span class="comment"># 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="variable language_">self</span>.size() <span class="keyword">or</span> j &gt;= <span class="variable language_">self</span>.size() <span class="keyword">or</span> i == j:</span><br><span class="line">            <span class="keyword">raise</span> IndexError()</span><br><span class="line">        <span class="comment"># 在无向图中，邻接矩阵关于主对角线对称，即满足 (i, j) == (j, i)</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat[i][j] = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat[j][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_edge</span>(<span class="params">self, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除边&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">        <span class="comment"># 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="variable language_">self</span>.size() <span class="keyword">or</span> j &gt;= <span class="variable language_">self</span>.size() <span class="keyword">or</span> i == j:</span><br><span class="line">            <span class="keyword">raise</span> IndexError()</span><br><span class="line">        <span class="variable language_">self</span>.adj_mat[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat[j][i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印邻接矩阵&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;顶点列表 =&quot;</span>, <span class="variable language_">self</span>.vertices)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;邻接矩阵 =&quot;</span>)</span><br><span class="line">        print_matrix(<span class="variable language_">self</span>.adj_mat)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化无向图</span></span><br><span class="line">    <span class="comment"># 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span></span><br><span class="line">    vertices = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">    edges = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">    graph = GraphAdjMat(vertices, edges)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n初始化后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加边</span></span><br><span class="line">    <span class="comment"># 顶点 1, 2 的索引分别为 0, 2</span></span><br><span class="line">    graph.add_edge(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n添加边 1-2 后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除边</span></span><br><span class="line">    <span class="comment"># 顶点 1, 3 的索引分别为 0, 1</span></span><br><span class="line">    graph.remove_edge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n删除边 1-3 后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加顶点</span></span><br><span class="line">    graph.add_vertex(<span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n添加顶点 6 后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除顶点</span></span><br><span class="line">    <span class="comment"># 顶点 3 的索引为 1</span></span><br><span class="line">    graph.remove_vertex(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n删除顶点 3 后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="基于邻接表的实现">基于邻接表的实现</h2><p>设无向图的顶点总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>、边总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> ，则可根据下图所示的方法实现各种操作。</p><ul><li><strong>添加边</strong>：在顶点对应链表的末尾添加边即可，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间。因为是无向图，所以需要同时添加两个方向的边。</li><li><strong>删除边</strong>：在顶点对应链表中查找并删除指定边，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 时间。在无向图中，需要同时删除两个方向的边。</li><li><strong>添加顶点</strong>：在邻接表中添加一个链表，并将新增顶点作为链表头节点，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间。</li><li><strong>删除顶点</strong>：需遍历整个邻接表，删除包含指定顶点的所有边，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 时间。</li><li><strong>初始化</strong>：在邻接表中创建 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个顶点和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">2m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">m</span></span></span></span> 条边，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 时间。</li></ul><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">初始化邻接表</button><button type="button" class="tab">添加边</button><button type="button" class="tab">删除边</button><button type="button" class="tab">添加顶点</button><button type="button" class="tab">删除顶点</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/63f65399/adjacency_list_step1_initialization.png" alt="邻接矩阵的初始化、增删边、增删顶点"></p></div><div class="tab-item-content"><p><img src="/posts/63f65399/adjacency_list_step2_add_edge.png" alt="adjacency_list_add_edge"></p></div><div class="tab-item-content"><p><img src="/posts/63f65399/adjacency_list_step3_remove_edge.png" alt="adjacency_list_remove_edge"></p></div><div class="tab-item-content"><p><img src="/posts/63f65399/adjacency_list_step4_add_vertex.png" alt="adjacency_list_add_vertex"></p></div><div class="tab-item-content"><p><img src="/posts/63f65399/adjacency_list_step5_remove_vertex.png" alt="adjacency_list_remove_vertex"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>以下是邻接表的代码实现。对比上图，实际代码有以下不同。</p><ul><li>为了方便添加与删除顶点，以及简化代码，我们使用列表（动态数组）来代替链表。</li><li>使用哈希表来存储邻接表，<code>key</code> 为顶点实例，<code>value</code> 为该顶点的邻接顶点列表（链表）。</li></ul><p>另外，我们在邻接表中使用 <code>Vertex</code> 类来表示顶点，这样做的原因是：如果与邻接矩阵一样，用列表索引来区分不同顶点，那么假设要删除索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的顶点，则需遍历整个邻接表，将所有大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的索引全部减 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，效率很低。而如果每个顶点都是唯一的 <code>Vertex</code> 实例，删除某一顶点之后就无须改动其他顶点了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjList</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于邻接表实现的无向图类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, edges: <span class="built_in">list</span>[<span class="built_in">list</span>[Vertex]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 邻接表，key：顶点，value：该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_list = <span class="built_in">dict</span>[Vertex, <span class="built_in">list</span>[Vertex]]()</span><br><span class="line">        <span class="comment"># 添加所有顶点和边</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="variable language_">self</span>.add_vertex(edge[<span class="number">0</span>])</span><br><span class="line">            <span class="variable language_">self</span>.add_vertex(edge[<span class="number">1</span>])</span><br><span class="line">            <span class="variable language_">self</span>.add_edge(edge[<span class="number">0</span>], edge[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取顶点数量&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.adj_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_edge</span>(<span class="params">self, vet1: Vertex, vet2: Vertex</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加边&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> vet1 <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list <span class="keyword">or</span> vet2 <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list <span class="keyword">or</span> vet1 == vet2:</span><br><span class="line">            <span class="keyword">raise</span> ValueError()</span><br><span class="line">        <span class="comment"># 添加边 vet1 - vet2</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_list[vet1].append(vet2)</span><br><span class="line">        <span class="variable language_">self</span>.adj_list[vet2].append(vet1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_edge</span>(<span class="params">self, vet1: Vertex, vet2: Vertex</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除边&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> vet1 <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list <span class="keyword">or</span> vet2 <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list <span class="keyword">or</span> vet1 == vet2:</span><br><span class="line">            <span class="keyword">raise</span> ValueError()</span><br><span class="line">        <span class="comment"># 删除边 vet1 - vet2</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_list[vet1].remove(vet2)</span><br><span class="line">        <span class="variable language_">self</span>.adj_list[vet2].remove(vet1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_vertex</span>(<span class="params">self, vet: Vertex</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加顶点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> vet <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 在邻接表中添加一个新链表</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_list[vet] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_vertex</span>(<span class="params">self, vet: Vertex</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除顶点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> vet <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list:</span><br><span class="line">            <span class="keyword">raise</span> ValueError()</span><br><span class="line">        <span class="comment"># 在邻接表中删除顶点 vet 对应的链表</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_list.pop(vet)</span><br><span class="line">        <span class="comment"># 遍历其他顶点的链表，删除所有包含 vet 的边</span></span><br><span class="line">        <span class="keyword">for</span> vertex <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list:</span><br><span class="line">            <span class="keyword">if</span> vet <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list[vertex]:</span><br><span class="line">                <span class="variable language_">self</span>.adj_list[vertex].remove(vet)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印邻接表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;邻接表 =&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> vertex <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list:</span><br><span class="line">            tmp = [v.val <span class="keyword">for</span> v <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list[vertex]]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;vertex.val&#125;</span>: <span class="subst">&#123;tmp&#125;</span>,&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化无向图</span></span><br><span class="line">    v = vals_to_vets([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line">    edges = [</span><br><span class="line">        [v[<span class="number">0</span>], v[<span class="number">1</span>]],</span><br><span class="line">        [v[<span class="number">0</span>], v[<span class="number">3</span>]],</span><br><span class="line">        [v[<span class="number">1</span>], v[<span class="number">2</span>]],</span><br><span class="line">        [v[<span class="number">2</span>], v[<span class="number">3</span>]],</span><br><span class="line">        [v[<span class="number">2</span>], v[<span class="number">4</span>]],</span><br><span class="line">        [v[<span class="number">3</span>], v[<span class="number">4</span>]],</span><br><span class="line">    ]</span><br><span class="line">    graph = GraphAdjList(edges)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n初始化后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加边</span></span><br><span class="line">    <span class="comment"># 顶点 1, 2 即 v[0], v[2]</span></span><br><span class="line">    graph.add_edge(v[<span class="number">0</span>], v[<span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n添加边 1-2 后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除边</span></span><br><span class="line">    <span class="comment"># 顶点 1, 3 即 v[0], v[1]</span></span><br><span class="line">    graph.remove_edge(v[<span class="number">0</span>], v[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n删除边 1-3 后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加顶点</span></span><br><span class="line">    v5 = Vertex(<span class="number">6</span>)</span><br><span class="line">    graph.add_vertex(v5)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n添加顶点 6 后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除顶点</span></span><br><span class="line">    <span class="comment"># 顶点 3 即 v[1]</span></span><br><span class="line">    graph.remove_vertex(v[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n删除顶点 3 后，图为&quot;</span>)</span><br><span class="line">    graph.<span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="效率对比">效率对比</h2><p>设图中共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个顶点和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 条边，下表对比了邻接矩阵和邻接表的时间效率和空间效率。</p><p align="center"> 表 <id> &nbsp; 邻接矩阵与邻接表对比 </id></p><table><thead><tr><th></th><th>邻接矩阵</th><th>邻接表（链表）</th><th>邻接表（哈希表）</th></tr></thead><tbody><tr><td>判断是否邻接</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>添加边</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>删除边</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>添加顶点</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>删除顶点</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>内存空间占用</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><p>观察上表，似乎邻接表（哈希表）的时间效率与空间效率最优。但实际上，在邻接矩阵中操作边的效率更高，只需一次数组访问或赋值操作即可。综合来看，邻接矩阵体现了“以空间换时间”的原则，而邻接表体现了“以时间换空间”的原则。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;图的基础操作&lt;/h1&gt;
&lt;p&gt;图的基础操作可分为对“边”的操作和对“顶点”的操作。在“邻接矩阵”和“邻接表”两种表示方法下，实现方式有所不同。&lt;/p&gt;
&lt;h2 id=&quot;基于邻接矩阵的实现&quot;&gt;基于邻接矩阵的实现&lt;/h2&gt;
&lt;p&gt;给定一个顶点数量为 &lt;span class=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="图" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
    <category term="图" scheme="https://chaoleweisi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://chaoleweisi.github.io/posts/ee040603/"/>
    <id>https://chaoleweisi.github.io/posts/ee040603/</id>
    <published>2024-10-13T05:00:14.000Z</published>
    <updated>2024-10-14T06:35:30.279Z</updated>
    
    <content type="html"><![CDATA[<h1>图</h1><p><u>图（graph）</u>是一种非线性数据结构，由<u>顶点（vertex）</u>和<u>边（edge）</u>组成。我们可以将图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 抽象地表示为一组顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 和一组边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 的集合。以下示例展示了一个包含 5 个顶点和 7 条边的图。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>V</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>E</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>G</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}V &amp; = \{ 1, 2, 3, 4, 5 \} \newlineE &amp; = \{ (1,2), (1,3), (1,5), (2,3), (2,4), (2,5), (4,5) \} \newlineG &amp; = \{ V, E \} \newline\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.5em;vertical-align:-2em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">}</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">)}</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">}</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>如果将顶点看作节点，将边看作连接各个节点的引用（指针），我们就可以将图看作一种从链表拓展而来的数据结构。如下图所示，<strong>相较于线性关系（链表）和分治关系（树），网络关系（图）的自由度更高</strong>，因而更为复杂。</p><p><img src="/posts/ee040603/linkedlist_tree_graph.png" alt="链表、树、图之间的关系"></p><h2 id="图的常见类型与术语">图的常见类型与术语</h2><p>根据边是否具有方向，可分为<u>无向图（undirected graph）</u>和<u>有向图（directed graph）</u>，如下图所示。</p><ul><li>在无向图中，边表示两顶点之间的“双向”连接关系，例如微信或 QQ 中的“好友关系”。</li><li>在有向图中，边具有方向性，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \rightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>←</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \leftarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 两个方向的边是相互独立的，例如微博或抖音上的“关注”与“被关注”关系。</li></ul><p><img src="/posts/ee040603/directed_graph.png" alt="有向图与无向图"></p><p>根据所有顶点是否连通，可分为<u>连通图（connected graph）</u>和<u>非连通图（disconnected graph）</u>，如下图所示。</p><ul><li>对于连通图，从某个顶点出发，可以到达其余任意顶点。</li><li>对于非连通图，从某个顶点出发，至少有一个顶点无法到达。</li></ul><p><img src="/posts/ee040603/connected_graph.png" alt="连通图与非连通图"></p><p>我们还可以为边添加“权重”变量，从而得到如下图所示的<u>有权图（weighted graph）</u>。例如在《王者荣耀》等手游中，系统会根据共同游戏时间来计算玩家之间的“亲密度”，这种亲密度网络就可以用有权图来表示。</p><p><img src="/posts/ee040603/weighted_graph.png" alt="有权图与无权图"></p><p>图数据结构包含以下常用术语。</p><ul><li><u>邻接（adjacency）</u>：当两顶点之间存在边相连时，称这两顶点“邻接”。在上图中，顶点 1 的邻接顶点为顶点 2、3、5。</li><li><u>路径（path）</u>：从顶点 A 到顶点 B 经过的边构成的序列被称为从 A 到 B 的“路径”。在上图中，边序列 1-5-2-4 是顶点 1 到顶点 4 的一条路径。</li><li><u>度（degree）</u>：一个顶点拥有的边数。对于有向图，<u>入度（in-degree）</u>表示有多少条边指向该顶点，<u>出度（out-degree）</u>表示有多少条边从该顶点指出。</li></ul><h2 id="图的表示">图的表示</h2><p>图的常用表示方式包括“邻接矩阵”和“邻接表”。以下使用无向图进行举例。</p><h3 id="邻接矩阵">邻接矩阵</h3><p>设图的顶点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，<u>邻接矩阵（adjacency matrix）</u>使用一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 表示两个顶点之间是否存在边。</p><p>如下图所示，设邻接矩阵为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>、顶点列表为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> ，那么矩阵元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M[i, j] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 表示顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">V[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 到顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">V[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 之间存在边，反之 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M[i, j] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 表示两顶点之间无边。</p><p><img src="/posts/ee040603/adjacency_matrix.png" alt="图的邻接矩阵表示"></p><p>邻接矩阵具有以下特性。</p><ul><li>顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义。</li><li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称。</li><li>将邻接矩阵的元素从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 替换为权重，则可表示有权图。</li></ul><p>使用邻接矩阵表示图时，我们可以直接访问矩阵元素以获取边，因此增删查改操作的效率很高，时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。然而，矩阵的空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，内存占用较多。</p><h3 id="邻接表">邻接表</h3><p><u>邻接表（adjacency list）</u>使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个链表来表示图，链表节点表示顶点。第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个链表对应顶点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。下图展示了一个使用邻接表存储的图的示例。</p><p><img src="/posts/ee040603/adjacency_list.png" alt="图的邻接表表示"></p><p>邻接表仅存储实际存在的边，而边的总数通常远小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵。</p><p>观察上图，<strong>邻接表结构与哈希表中的“链式地址”非常相似，因此我们也可以采用类似的方法来优化效率</strong>。比如当链表较长时，可以将链表转化为 AVL 树或红黑树，从而将时间效率从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 优化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；还可以把链表转换为哈希表，从而将时间复杂度降至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><h2 id="图的常见应用">图的常见应用</h2><p>如下表所示，许多现实系统可以用图来建模，相应的问题也可以约化为图计算问题。</p><p align="center"> 表 <id> &nbsp; 现实生活中常见的图 </id></p><table><thead><tr><th></th><th>顶点</th><th>边</th><th>图计算问题</th></tr></thead><tbody><tr><td>社交网络</td><td>用户</td><td>好友关系</td><td>潜在好友推荐</td></tr><tr><td>地铁线路</td><td>站点</td><td>站点间的连通性</td><td>最短路线推荐</td></tr><tr><td>太阳系</td><td>星体</td><td>星体间的万有引力作用</td><td>行星轨道计算</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;图&lt;/h1&gt;
&lt;p&gt;&lt;u&gt;图（graph）&lt;/u&gt;是一种非线性数据结构，由&lt;u&gt;顶点（vertex）&lt;/u&gt;和&lt;u&gt;边（edge）&lt;/u&gt;组成。我们可以将图 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmln</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="图" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
    <category term="图" scheme="https://chaoleweisi.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>堆——小结</title>
    <link href="https://chaoleweisi.github.io/posts/c0e8ccc7/"/>
    <id>https://chaoleweisi.github.io/posts/c0e8ccc7/</id>
    <published>2024-10-13T04:59:14.000Z</published>
    <updated>2024-10-14T06:28:10.066Z</updated>
    
    <content type="html"><![CDATA[<h1>小结</h1><h3 id="重点回顾">重点回顾</h3><ul><li>堆是一棵完全二叉树，根据成立条件可分为大顶堆和小顶堆。大（小）顶堆的堆顶元素是最大（小）的。</li><li>优先队列的定义是具有出队优先级的队列，通常使用堆来实现。</li><li>堆的常用操作及其对应的时间复杂度包括：元素入堆 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>、堆顶元素出堆 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 和访问堆顶元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 等。</li><li>完全二叉树非常适合用数组表示，因此我们通常使用数组来存储堆。</li><li>堆化操作用于维护堆的性质，在入堆和出堆操作中都会用到。</li><li>输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个元素并建堆的时间复杂度可以优化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，非常高效。</li><li>Top-k 是一个经典算法问题，可以使用堆数据结构高效解决，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 。</li></ul><h3 id="Q-A">Q &amp; A</h3><p><strong>Q</strong>：数据结构的“堆”与内存管理的“堆”是同一个概念吗？</p><p>两者不是同一个概念，只是碰巧都叫“堆”。计算机系统内存中的堆是动态内存分配的一部分，程序在运行时可以使用它来存储数据。程序可以请求一定量的堆内存，用于存储如对象和数组等复杂结构。当这些数据不再需要时，程序需要释放这些内存，以防止内存泄漏。相较于栈内存，堆内存的管理和使用需要更谨慎，使用不当可能会导致内存泄漏和野指针等问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;小结&lt;/h1&gt;
&lt;h3 id=&quot;重点回顾&quot;&gt;重点回顾&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;堆是一棵完全二叉树，根据成立条件可分为大顶堆和小顶堆。大（小）顶堆的堆顶元素是最大（小）的。&lt;/li&gt;
&lt;li&gt;优先队列的定义是具有出队优先级的队列，通常使用堆来实现。&lt;/li&gt;
&lt;li&gt;堆</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="堆" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86/"/>
    
    
    <category term="总结" scheme="https://chaoleweisi.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Top-k问题</title>
    <link href="https://chaoleweisi.github.io/posts/a3621db4/"/>
    <id>https://chaoleweisi.github.io/posts/a3621db4/</id>
    <published>2024-10-13T04:59:14.000Z</published>
    <updated>2024-10-14T08:05:25.398Z</updated>
    
    <content type="html"><![CDATA[<h1>Top-k 问题</h1><pre><code>给定一个长度为 $n$ 的无序数组 `nums` ，请返回数组中最大的 $k$ 个元素。</code></pre><p>对于该问题，我们先介绍两种思路比较直接的解法，再介绍效率更高的堆解法。</p><h2 id="方法一：遍历选择">方法一：遍历选择</h2><p>我们可以进行下图所示的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 轮遍历，分别在每轮中提取第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.123em;"></span><span class="minner">…</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 大的元素，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mclose">)</span></span></span></span> 。</p><p>此方法只适用于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≪</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k \ll n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的情况，因为当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 比较接近时，其时间复杂度趋向于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，非常耗时。</p><p><img src="/posts/a3621db4/top_k_traversal.png" alt="遍历寻找最大的 k 个元素"></p><p>tip</p><pre><code>当 $k = n$ 时，我们可以得到完整的有序序列，此时等价于“选择排序”算法。</code></pre><h2 id="方法二：排序">方法二：排序</h2><p>如下图所示，我们可以先对数组 <code>nums</code> 进行排序，再返回最右边的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个元素，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><p>显然，该方法“超额”完成任务了，因为我们只需找出最大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个元素即可，而不需要排序其他元素。</p><p><img src="/posts/a3621db4/top_k_sorting.png" alt="排序寻找最大的 k 个元素"></p><h2 id="方法三：堆">方法三：堆</h2><p>我们可以基于堆更加高效地解决 Top-k 问题，流程如下图所示。</p><ol><li>初始化一个小顶堆，其堆顶元素最小。</li><li>先将数组的前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个元素依次入堆。</li><li>从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。</li><li>遍历完成后，堆中保存的就是最大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个元素。</li></ol><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">tab 1</button><button type="button" class="tab">tab 2</button><button type="button" class="tab">tab 3</button><button type="button" class="tab">tab 4</button><button type="button" class="tab">tab 5</button><button type="button" class="tab">tab 6</button><button type="button" class="tab">tab 7</button><button type="button" class="tab">tab 8</button><button type="button" class="tab">tab 9</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/a3621db4/top_k_heap_step1.png" alt="基于堆寻找最大的 k 个元素"></p></div><div class="tab-item-content"><p><img src="/posts/a3621db4/top_k_heap_step2.png" alt="top_k_heap_step2"></p></div><div class="tab-item-content"><p><img src="/posts/a3621db4/top_k_heap_step3.png" alt="top_k_heap_step3"></p></div><div class="tab-item-content"><p><img src="/posts/a3621db4/top_k_heap_step4.png" alt="top_k_heap_step4"></p></div><div class="tab-item-content"><p><img src="/posts/a3621db4/top_k_heap_step5.png" alt="top_k_heap_step5"></p></div><div class="tab-item-content"><p><img src="/posts/a3621db4/top_k_heap_step6.png" alt="top_k_heap_step6"></p></div><div class="tab-item-content"><p><img src="/posts/a3621db4/top_k_heap_step7.png" alt="top_k_heap_step7"></p></div><div class="tab-item-content"><p><img src="/posts/a3621db4/top_k_heap_step8.png" alt="top_k_heap_step8"></p></div><div class="tab-item-content"><p><img src="/posts/a3621db4/top_k_heap_step9.png" alt="top_k_heap_step9"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">top_k_heap</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于堆查找数组中最大的 k 个元素&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化小顶堆</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="comment"># 将数组的前 k 个元素入堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        heapq.heappush(heap, nums[i])</span><br><span class="line">    <span class="comment"># 从第 k+1 个元素开始，保持堆的长度为 k</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">            heapq.heappush(heap, nums[i])</span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure><p>总共执行了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 轮入堆和出堆，堆的最大长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，因此时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 。该方法的效率很高，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 较小时，时间复杂度趋向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 较大时，时间复杂度不会超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><p>另外，该方法适用于动态数据流的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现最大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个元素的动态更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Top-k 问题&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;给定一个长度为 $n$ 的无序数组 `nums` ，请返回数组中最大的 $k$ 个元素。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于该问题，我们先介绍两种思路比较直接的解法，再介绍效率更高的堆解法。&lt;/p&gt;
&lt;h2 id=&quot;方</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="堆" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86/"/>
    
    
    <category term="堆" scheme="https://chaoleweisi.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>建堆操作</title>
    <link href="https://chaoleweisi.github.io/posts/3006101f/"/>
    <id>https://chaoleweisi.github.io/posts/3006101f/</id>
    <published>2024-10-13T04:58:14.000Z</published>
    <updated>2024-10-14T06:27:50.460Z</updated>
    
    <content type="html"><![CDATA[<h1>建堆操作</h1><p>在某些情况下，我们希望使用一个列表的所有元素来构建一个堆，这个过程被称为“建堆操作”。</p><h2 id="借助入堆操作实现">借助入堆操作实现</h2><p>我们首先创建一个空堆，然后遍历列表，依次对每个元素执行“入堆操作”，即先将元素添加至堆的尾部，再对该元素执行“从底至顶”堆化。</p><p>每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进二叉树的，因此堆是“自上而下”构建的。</p><p>设元素数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，每个元素的入堆操作使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> 时间，因此该建堆方法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><h2 id="通过遍历堆化实现">通过遍历堆化实现</h2><p>实际上，我们可以实现一种更为高效的建堆方法，共分为两步。</p><ol><li>将列表所有元素原封不动地添加到堆中，此时堆的性质尚未得到满足。</li><li>倒序遍历堆（层序遍历的倒序），依次对每个非叶节点执行“从顶至底堆化”。</li></ol><p><strong>每当堆化一个节点后，以该节点为根节点的子树就形成一个合法的子堆</strong>。而由于是倒序遍历，因此堆是“自下而上”构建的。</p><p>之所以选择倒序遍历，是因为这样能够保证当前节点之下的子树已经是合法的子堆，这样堆化当前节点才是有效的。</p><p>值得说明的是，<strong>由于叶节点没有子节点，因此它们天然就是合法的子堆，无须堆化</strong>。如以下代码所示，最后一个非叶节点是最后一个节点的父节点，我们从它开始倒序遍历并执行堆化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;构造方法，根据输入列表建堆&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将列表元素原封不动添加进堆</span></span><br><span class="line">    <span class="variable language_">self</span>.max_heap = nums</span><br><span class="line">    <span class="comment"># 堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.parent(<span class="variable language_">self</span>.size() - <span class="number">1</span>), -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="variable language_">self</span>.sift_down(i)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>下面，我们来尝试推算第二种建堆方法的时间复杂度。</p><ul><li>假设完全二叉树的节点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，则叶节点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n + 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span></span></span></span> 为向下整除。因此需要堆化的节点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n - 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span> 。</li><li>在从顶至底堆化的过程中，每个节点最多堆化到叶节点，因此最大迭代次数为二叉树高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span> 。</li></ul><p>将上述两者相乘，可得到建堆过程的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。<strong>但这个估算结果并不准确，因为我们没有考虑到二叉树底层节点数量远多于顶层节点的性质</strong>。</p><p>接下来我们来进行更为准确的计算。为了降低计算难度，假设给定一个节点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 、高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 的“完美二叉树”，该假设不会影响计算结果的正确性。</p><p><img src="/posts/3006101f/heapify_operations_count.png" alt="完美二叉树的各层节点数量"></p><p>如上图所示，节点“从顶至底堆化”的最大迭代次数等于该节点到叶节点的距离，而该距离正是“节点高度”。因此，我们可以对各层的“节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 节点高度”求和，<strong>得到所有节点的堆化迭代次数的总和</strong>。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mn>0</mn></msup><mi>h</mi><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \dots + 2^{(h-1)}\times1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>化简上式需要借助中学的数列知识，先将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span> 乘以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> ，得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mn>2</mn><mn>0</mn></msup><mi>h</mi><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>×</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mn>2</mn><mn>1</mn></msup><mi>h</mi><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mn>3</mn></msup><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mi>h</mi></msup><mo>×</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}T(h) &amp; = 2^0h + 2^1(h-1) + 2^2(h-2) + \dots + 2^{h-1}\times1 \newline2 T(h) &amp; = 2^1h + 2^2(h-1) + 2^3(h-2) + \dots + 2^{h}\times1 \newline\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.1182em;vertical-align:-1.3091em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8091em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span><span style="top:-2.3509em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3091em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8091em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-2.3509em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3091em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>使用错位相减法，用下式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2 T(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span> 减去上式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span> ，可得：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>−</mo><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msup><mn>2</mn><mn>0</mn></msup><mi>h</mi><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2T(h) - T(h) = T(h) = -2^0h + 2^1 + 2^2 + \dots + 2^{h-1} + 2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8991em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span></p><p>观察上式，发现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span> 是一个等比数列，可直接使用求和公式，得到时间复杂度为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mn>2</mn><mi>h</mi></msup></mrow><mrow><mn>1</mn><mo>−</mo><mn>2</mn></mrow></mfrac><mo>−</mo><mi>h</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mi>h</mi><mo>−</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>h</mi></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}T(h) &amp; = 2 \frac{1 - 2^h}{1 - 2} - h \newline&amp; = 2^{h+1} - h - 2 \newline&amp; = O(2^h)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.7137em;vertical-align:-2.6068em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1068em;"><span style="top:-5.1068em;"><span class="pstrut" style="height:3.5261em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span><span style="top:-3.1384em;"><span class="pstrut" style="height:3.5261em;"></span><span class="mord"></span></span><span style="top:-1.5793em;"><span class="pstrut" style="height:3.5261em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6068em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1068em;"><span style="top:-5.1068em;"><span class="pstrut" style="height:3.5261em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5261em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">h</span></span></span><span style="top:-3.1384em;"><span class="pstrut" style="height:3.5261em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-1.5793em;"><span class="pstrut" style="height:3.5261em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6068em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>进一步，高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 的完美二叉树的节点数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = 2^{h+1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，易得复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>h</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^h) = O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。以上推算表明，<strong>输入列表并建堆的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，非常高效</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;建堆操作&lt;/h1&gt;
&lt;p&gt;在某些情况下，我们希望使用一个列表的所有元素来构建一个堆，这个过程被称为“建堆操作”。&lt;/p&gt;
&lt;h2 id=&quot;借助入堆操作实现&quot;&gt;借助入堆操作实现&lt;/h2&gt;
&lt;p&gt;我们首先创建一个空堆，然后遍历列表，依次对每个元素执行“入堆操作”，即先将元素添</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="堆" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86/"/>
    
    
    <category term="堆" scheme="https://chaoleweisi.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://chaoleweisi.github.io/posts/fab451a5/"/>
    <id>https://chaoleweisi.github.io/posts/fab451a5/</id>
    <published>2024-10-13T04:45:14.000Z</published>
    <updated>2024-10-14T08:00:45.074Z</updated>
    
    <content type="html"><![CDATA[<h1>堆</h1><p><u>堆（heap）</u>是一种满足特定条件的完全二叉树，主要可分为两种类型，如下图所示。</p><ul><li><u>小顶堆（min heap）</u>：任意节点的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span> 其子节点的值。</li><li><u>大顶堆（max heap）</u>：任意节点的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> 其子节点的值。</li></ul><p><img src="/posts/fab451a5/min_heap_and_max_heap.png" alt="小顶堆与大顶堆"></p><p>堆作为完全二叉树的一个特例，具有以下特性。</p><ul><li>最底层节点靠左填充，其他层的节点都被填满。</li><li>我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”。</li><li>对于大顶堆（小顶堆），堆顶元素（根节点）的值是最大（最小）的。</li></ul><h2 id="堆的常用操作">堆的常用操作</h2><p>需要指出的是，许多编程语言提供的是<u>优先队列（priority queue）</u>，这是一种抽象的数据结构，定义为具有优先级排序的队列。</p><p>实际上，<strong>堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列</strong>。从使用角度来看，我们可以将“优先队列”和“堆”看作等价的数据结构。因此，本书对两者不做特别区分，统一称作“堆”。</p><p>堆的常用操作见下表，方法名需要根据编程语言来确定。</p><p align="center"> 表 <id> &nbsp; 堆的操作效率 </id></p><table><thead><tr><th>方法名</th><th>描述</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>push()</code></td><td>元素入堆</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>pop()</code></td><td>堆顶元素出堆</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>peek()</code></td><td>访问堆顶元素（对于大 / 小顶堆分别为最大 / 小值）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>size()</code></td><td>获取堆的元素数量</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>isEmpty()</code></td><td>判断堆是否为空</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><p>在实际应用中，我们可以直接使用编程语言提供的堆类（或优先队列类）。</p><p>类似于排序算法中的“从小到大排列”和“从大到小排列”，我们可以通过设置一个 <code>flag</code> 或修改 <code>Comparator</code> 实现“小顶堆”与“大顶堆”之间的转换。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化小顶堆</span></span><br><span class="line">min_heap, flag = [], <span class="number">1</span></span><br><span class="line"><span class="comment"># 初始化大顶堆</span></span><br><span class="line">max_heap, flag = [], -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的 heapq 模块默认实现小顶堆</span></span><br><span class="line"><span class="comment"># 考虑将“元素取负”后再入堆，这样就可以将大小关系颠倒，从而实现大顶堆</span></span><br><span class="line"><span class="comment"># 在本示例中，flag = 1 时对应小顶堆，flag = -1 时对应大顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入堆</span></span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">1</span>)</span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">3</span>)</span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">2</span>)</span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">5</span>)</span><br><span class="line">heapq.heappush(max_heap, flag * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取堆顶元素</span></span><br><span class="line">peek: <span class="built_in">int</span> = flag * max_heap[<span class="number">0</span>] <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆顶元素出堆</span></span><br><span class="line"><span class="comment"># 出堆元素会形成一个从大到小的序列</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 5</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 4</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 3</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 2</span></span><br><span class="line">val = flag * heapq.heappop(max_heap) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取堆大小</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(max_heap)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断堆是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="keyword">not</span> max_heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入列表并建堆</span></span><br><span class="line">min_heap: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">heapq.heapify(min_heap)</span><br></pre></td></tr></table></figure><h2 id="堆的实现">堆的实现</h2><p>下文实现的是大顶堆。若要将其转换为小顶堆，只需将所有大小逻辑判断进行逆转（例如，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> 替换为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span> ）。感兴趣的读者可以自行实现。</p><h3 id="堆的存储与表示">堆的存储与表示</h3><p>“二叉树”章节讲过，完全二叉树非常适合用数组来表示。由于堆正是一种完全二叉树，<strong>因此我们将采用数组来存储堆</strong>。</p><p>当使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。<strong>节点指针通过索引映射公式来实现</strong>。</p><p>如下图所示，给定索引 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，其左子节点的索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，右子节点的索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2i + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> ，父节点的索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(i - 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>（向下整除）。当索引越界时，表示空节点或节点不存在。</p><p><img src="/posts/fab451a5/representation_of_heap.png" alt="堆的表示与存储"></p><p>我们可以将索引映射公式封装成函数，方便后续使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">left</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取左子节点的索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">right</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取右子节点的索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取父节点的索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) // <span class="number">2</span>  <span class="comment"># 向下整除</span></span><br></pre></td></tr></table></figure><h3 id="访问堆顶元素">访问堆顶元素</h3><p>堆顶元素即为二叉树的根节点，也就是列表的首个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;访问堆顶元素&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.max_heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="元素入堆">元素入堆</h3><p>给定元素 <code>val</code> ，我们首先将其添加到堆底。添加之后，由于 <code>val</code> 可能大于堆中其他元素，堆的成立条件可能已被破坏，<strong>因此需要修复从插入节点到根节点的路径上的各个节点</strong>，这个操作被称为<u>堆化（heapify）</u>。</p><p>考虑从入堆节点开始，<strong>从底至顶执行堆化</strong>。如下图所示，我们比较插入节点与其父节点的值，如果插入节点更大，则将它们交换。然后继续执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无须交换的节点时结束。</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">tab 1</button><button type="button" class="tab">tab 2</button><button type="button" class="tab">tab 3</button><button type="button" class="tab">tab 4</button><button type="button" class="tab">tab 5</button><button type="button" class="tab">tab 6</button><button type="button" class="tab">tab 7</button><button type="button" class="tab">tab 8</button><button type="button" class="tab">tab 9</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/fab451a5/heap_push_step1.png" alt="元素入堆步骤"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_push_step2.png" alt="heap_push_step2"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_push_step3.png" alt="heap_push_step3"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_push_step4.png" alt="heap_push_step4"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_push_step5.png" alt="heap_push_step5"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_push_step6.png" alt="heap_push_step6"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_push_step7.png" alt="heap_push_step7"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_push_step8.png" alt="heap_push_step8"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_push_step9.png" alt="heap_push_step9"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>设节点总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，则树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。由此可知，堆化操作的循环轮数最多为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，<strong>元素入堆操作的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong> 。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;元素入堆&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 添加节点</span></span><br><span class="line">    <span class="variable language_">self</span>.max_heap.append(val)</span><br><span class="line">    <span class="comment"># 从底至顶堆化</span></span><br><span class="line">    <span class="variable language_">self</span>.sift_up(<span class="variable language_">self</span>.size() - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sift_up</span>(<span class="params">self, i: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从节点 i 开始，从底至顶堆化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 获取节点 i 的父节点</span></span><br><span class="line">        p = <span class="variable language_">self</span>.parent(i)</span><br><span class="line">        <span class="comment"># 当“越过根节点”或“节点无须修复”时，结束堆化</span></span><br><span class="line">        <span class="keyword">if</span> p &lt; <span class="number">0</span> <span class="keyword">or</span> <span class="variable language_">self</span>.max_heap[i] &lt;= <span class="variable language_">self</span>.max_heap[p]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 交换两节点</span></span><br><span class="line">        <span class="variable language_">self</span>.swap(i, p)</span><br><span class="line">        <span class="comment"># 循环向上堆化</span></span><br><span class="line">        i = p</span><br></pre></td></tr></table></figure><h3 id="堆顶元素出堆">堆顶元素出堆</h3><p>堆顶元素是二叉树的根节点，即列表首元素。如果我们直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化，这将使得后续使用堆化进行修复变得困难。为了尽量减少元素索引的变动，我们采用以下操作步骤。</p><ol><li>交换堆顶元素与堆底元素（交换根节点与最右叶节点）。</li><li>交换完成后，将堆底从列表中删除（注意，由于已经交换，因此实际上删除的是原来的堆顶元素）。</li><li>从根节点开始，<strong>从顶至底执行堆化</strong>。</li></ol><p>如下图所示，<strong>“从顶至底堆化”的操作方向与“从底至顶堆化”相反</strong>，我们将根节点的值与其两个子节点的值进行比较，将最大的子节点与根节点交换。然后循环执行此操作，直到越过叶节点或遇到无须交换的节点时结束。</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">tab 1</button><button type="button" class="tab">tab 2</button><button type="button" class="tab">tab 3</button><button type="button" class="tab">tab 4</button><button type="button" class="tab">tab 5</button><button type="button" class="tab">tab 6</button><button type="button" class="tab">tab 7</button><button type="button" class="tab">tab 8</button><button type="button" class="tab">tab 9</button><button type="button" class="tab">tab 10</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/fab451a5/heap_pop_step1.png" alt="堆顶元素出堆步骤"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_pop_step2.png" alt="heap_pop_step2"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_pop_step3.png" alt="heap_pop_step3"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_pop_step4.png" alt="heap_pop_step4"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_pop_step5.png" alt="heap_pop_step5"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_pop_step6.png" alt="heap_pop_step6"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_pop_step7.png" alt="heap_pop_step7"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_pop_step8.png" alt="heap_pop_step8"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_pop_step9.png" alt="heap_pop_step9"></p></div><div class="tab-item-content"><p><img src="/posts/fab451a5/heap_pop_step10.png" alt="heap_pop_step10"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>与元素入堆操作相似，堆顶元素出堆操作的时间复杂度也为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;元素出堆&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 判空处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&quot;堆为空&quot;</span>)</span><br><span class="line">    <span class="comment"># 交换根节点与最右叶节点（交换首元素与尾元素）</span></span><br><span class="line">    <span class="variable language_">self</span>.swap(<span class="number">0</span>, <span class="variable language_">self</span>.size() - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 删除节点</span></span><br><span class="line">    val = <span class="variable language_">self</span>.max_heap.pop()</span><br><span class="line">    <span class="comment"># 从顶至底堆化</span></span><br><span class="line">    <span class="variable language_">self</span>.sift_down(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 返回堆顶元素</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">self, i: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从节点 i 开始，从顶至底堆化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        l, r, ma = <span class="variable language_">self</span>.left(i), <span class="variable language_">self</span>.right(i), i</span><br><span class="line">        <span class="keyword">if</span> l &lt; <span class="variable language_">self</span>.size() <span class="keyword">and</span> <span class="variable language_">self</span>.max_heap[l] &gt; <span class="variable language_">self</span>.max_heap[ma]:</span><br><span class="line">            ma = l</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="variable language_">self</span>.size() <span class="keyword">and</span> <span class="variable language_">self</span>.max_heap[r] &gt; <span class="variable language_">self</span>.max_heap[ma]:</span><br><span class="line">            ma = r</span><br><span class="line">        <span class="comment"># 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ma == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 交换两节点</span></span><br><span class="line">        <span class="variable language_">self</span>.swap(i, ma)</span><br><span class="line">        <span class="comment"># 循环向下堆化</span></span><br><span class="line">        i = ma</span><br></pre></td></tr></table></figure><h2 id="堆的常见应用">堆的常见应用</h2><ul><li><strong>优先队列</strong>：堆通常作为实现优先队列的首选数据结构，其入队和出队操作的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，而建堆操作为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，这些操作都非常高效。</li><li><strong>堆排序</strong>：给定一组数据，我们可以用它们建立一个堆，然后不断地执行元素出堆操作，从而得到有序数据。然而，我们通常会使用一种更优雅的方式实现堆排序，详见“堆排序”章节。</li><li><strong>获取最大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个元素</strong>：这是一个经典的算法问题，同时也是一种典型应用，例如选择热度前 10 的新闻作为微博热搜，选取销量前 10 的商品等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;堆&lt;/h1&gt;
&lt;p&gt;&lt;u&gt;堆（heap）&lt;/u&gt;是一种满足特定条件的完全二叉树，主要可分为两种类型，如下图所示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;u&gt;小顶堆（min heap）&lt;/u&gt;：任意节点的值 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="堆" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86/"/>
    
    
    <category term="堆" scheme="https://chaoleweisi.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>树——小结</title>
    <link href="https://chaoleweisi.github.io/posts/18e1063c/"/>
    <id>https://chaoleweisi.github.io/posts/18e1063c/</id>
    <published>2024-10-13T04:44:14.000Z</published>
    <updated>2024-10-14T06:35:04.886Z</updated>
    
    <content type="html"><![CDATA[<h1>小结</h1><h3 id="重点回顾">重点回顾</h3><ul><li>二叉树是一种非线性数据结构，体现“一分为二”的分治逻辑。每个二叉树节点包含一个值以及两个指针，分别指向其左子节点和右子节点。</li><li>对于二叉树中的某个节点，其左（右）子节点及其以下形成的树被称为该节点的左（右）子树。</li><li>二叉树的相关术语包括根节点、叶节点、层、度、边、高度和深度等。</li><li>二叉树的初始化、节点插入和节点删除操作与链表操作方法类似。</li><li>常见的二叉树类型有完美二叉树、完全二叉树、完满二叉树和平衡二叉树。完美二叉树是最理想的状态，而链表是退化后的最差状态。</li><li>二叉树可以用数组表示，方法是将节点值和空位按层序遍历顺序排列，并根据父节点与子节点之间的索引映射关系来实现指针。</li><li>二叉树的层序遍历是一种广度优先搜索方法，它体现了“一圈一圈向外扩展”的逐层遍历方式，通常通过队列来实现。</li><li>前序、中序、后序遍历皆属于深度优先搜索，它们体现了“先走到尽头，再回溯继续”的遍历方式，通常使用递归来实现。</li><li>二叉搜索树是一种高效的元素查找数据结构，其查找、插入和删除操作的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。当二叉搜索树退化为链表时，各项时间复杂度会劣化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</li><li>AVL 树，也称平衡二叉搜索树，它通过旋转操作确保在不断插入和删除节点后树仍然保持平衡。</li><li>AVL 树的旋转操作包括右旋、左旋、先右旋再左旋、先左旋再右旋。在插入或删除节点后，AVL 树会从底向顶执行旋转操作，使树重新恢复平衡。</li></ul><h3 id="Q-A">Q &amp; A</h3><p><strong>Q</strong>：对于只有一个节点的二叉树，树的高度和根节点的深度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 吗？</p><p>是的，因为高度和深度通常定义为“经过的边的数量”。</p><p><strong>Q</strong>：二叉树中的插入与删除一般由一套操作配合完成，这里的“一套操作”指什么呢？可以理解为资源的子节点的资源释放吗？</p><p>拿二叉搜索树来举例，删除节点操作要分三种情况处理，其中每种情况都需要进行多个步骤的节点操作。</p><p><strong>Q</strong>：为什么 DFS 遍历二叉树有前、中、后三种顺序，分别有什么用呢？</p><p>与顺序和逆序遍历数组类似，前序、中序、后序遍历是三种二叉树遍历方法，我们可以使用它们得到一个特定顺序的遍历结果。例如在二叉搜索树中，由于节点大小满足 <code>左子节点值 &lt; 根节点值 &lt; 右子节点值</code> ，因此我们只要按照“左 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 根 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 右”的优先级遍历树，就可以获得有序的节点序列。</p><p><strong>Q</strong>：右旋操作是处理失衡节点 <code>node</code>、<code>child</code>、<code>grand_child</code> 之间的关系，那 <code>node</code> 的父节点和 <code>node</code> 原来的连接不需要维护吗？右旋操作后岂不是断掉了？</p><p>我们需要从递归的视角来看这个问题。右旋操作 <code>right_rotate(root)</code> 传入的是子树的根节点，最终 <code>return child</code> 返回旋转之后的子树的根节点。子树的根节点和其父节点的连接是在该函数返回后完成的，不属于右旋操作的维护范围。</p><p><strong>Q</strong>：在 C++ 中，函数被划分到 <code>private</code> 和 <code>public</code> 中，这方面有什么考量吗？为什么要将 <code>height()</code> 函数和 <code>updateHeight()</code> 函数分别放在 <code>public</code> 和 <code>private</code> 中呢？</p><p>主要看方法的使用范围，如果方法只在类内部使用，那么就设计为 <code>private</code> 。例如，用户单独调用 <code>updateHeight()</code> 是没有意义的，它只是插入、删除操作中的一步。而 <code>height()</code> 是访问节点高度，类似于 <code>vector.size()</code> ，因此设置成 <code>public</code> 以便使用。</p><p><strong>Q</strong>：如何从一组输入数据构建一棵二叉搜索树？根节点的选择是不是很重要？</p><p>是的，构建树的方法已在二叉搜索树代码中的 <code>build_tree()</code> 方法中给出。至于根节点的选择，我们通常会将输入数据排序，然后将中点元素作为根节点，再递归地构建左右子树。这样做可以最大程度保证树的平衡性。</p><p><strong>Q</strong>：在 Java 中，字符串对比是否一定要用 <code>equals()</code> 方法？</p><p>在 Java 中，对于基本数据类型，<code>==</code> 用于对比两个变量的值是否相等。对于引用类型，两种符号的工作原理是不同的。</p><ul><li><code>==</code> ：用来比较两个变量是否指向同一个对象，即它们在内存中的位置是否相同。</li><li><code>equals()</code>：用来对比两个对象的值是否相等。</li></ul><p>因此，如果要对比值，我们应该使用 <code>equals()</code> 。然而，通过 <code>String a = &quot;hi&quot;; String b = &quot;hi&quot;;</code> 初始化的字符串都存储在字符串常量池中，它们指向同一个对象，因此也可以用 <code>a == b</code> 来比较两个字符串的内容。</p><p><strong>Q</strong>：广度优先遍历到最底层之前，队列中的节点数量是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span> 吗？</p><p>是的，例如高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">h = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的满二叉树，其节点总数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">n = 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> ，则底层节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>=</mo><msup><mn>2</mn><mi>h</mi></msup><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">4 = 2^h = (n + 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span> 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;小结&lt;/h1&gt;
&lt;h3 id=&quot;重点回顾&quot;&gt;重点回顾&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;二叉树是一种非线性数据结构，体现“一分为二”的分治逻辑。每个二叉树节点包含一个值以及两个指针，分别指向其左子节点和右子节点。&lt;/li&gt;
&lt;li&gt;对于二叉树中的某个节点，其左（右）子节点及其以</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
    
    <category term="总结" scheme="https://chaoleweisi.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://chaoleweisi.github.io/posts/973716ad/"/>
    <id>https://chaoleweisi.github.io/posts/973716ad/</id>
    <published>2024-10-13T04:31:14.000Z</published>
    <updated>2024-10-14T08:01:55.916Z</updated>
    
    <content type="html"><![CDATA[<h1>AVL 树 *</h1><p>在“二叉搜索树”章节中我们提到，在多次插入和删除操作后，二叉搜索树可能退化为链表。在这种情况下，所有操作的时间复杂度将从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 劣化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><p>如下图所示，经过两次删除节点操作，这棵二叉搜索树便会退化为链表。</p><p><img src="/posts/973716ad/avltree_degradation_from_removing_node.png" alt="AVL 树在删除节点后发生退化"></p><p>再例如，在下图所示的完美二叉树中插入两个节点后，树将严重向左倾斜，查找操作的时间复杂度也随之劣化。</p><p><img src="/posts/973716ad/avltree_degradation_from_inserting_node.png" alt="AVL 树在插入节点后发生退化"></p><p>1962 年 G. M. Adelson-Velsky 和 E. M. Landis 在论文“An algorithm for the organization of information”中提出了 <u>AVL 树</u>。论文中详细描述了一系列操作，确保在持续添加和删除节点后，AVL 树不会退化，从而使得各种操作的时间复杂度保持在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 级别。换句话说，在需要频繁进行增删查改操作的场景中，AVL 树能始终保持高效的数据操作性能，具有很好的应用价值。</p><h2 id="AVL-树常见术语">AVL 树常见术语</h2><p>AVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种<u>平衡二叉搜索树（balanced binary search tree）</u>。</p><h3 id="节点高度">节点高度</h3><p>由于 AVL 树的相关操作需要获取节点高度，因此我们需要为节点类添加 <code>height</code> 变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;AVL 树节点类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val: <span class="built_in">int</span> = val                 <span class="comment"># 节点值</span></span><br><span class="line">        <span class="variable language_">self</span>.height: <span class="built_in">int</span> = <span class="number">0</span>                <span class="comment"># 节点高度</span></span><br><span class="line">        <span class="variable language_">self</span>.left: TreeNode | <span class="literal">None</span> = <span class="literal">None</span>   <span class="comment"># 左子节点引用</span></span><br><span class="line">        <span class="variable language_">self</span>.right: TreeNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 右子节点引用</span></span><br></pre></td></tr></table></figure><p>“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。需要特别注意的是，叶节点的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ，而空节点的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 。我们将创建两个工具函数，分别用于获取和更新节点的高度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self, node: TreeNode | <span class="literal">None</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取节点高度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> node.height</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_height</span>(<span class="params">self, node: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;更新节点高度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    node.height = <span class="built_in">max</span>([<span class="variable language_">self</span>.height(node.left), <span class="variable language_">self</span>.height(node.right)]) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="节点平衡因子">节点平衡因子</h3><p>节点的<u>平衡因子（balance factor）</u>定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 。我们同样将获取节点平衡因子的功能封装成函数，方便后续使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">balance_factor</span>(<span class="params">self, node: TreeNode | <span class="literal">None</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取平衡因子&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.height(node.left) - <span class="variable language_">self</span>.height(node.right)</span><br></pre></td></tr></table></figure><pre><code>设平衡因子为 $f$ ，则一棵 AVL 树的任意节点的平衡因子皆满足 $-1 \le f \le 1$ 。</code></pre><h2 id="AVL-树旋转">AVL 树旋转</h2><p>AVL 树的特点在于“旋转”操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，<strong>旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”</strong>。</p><p>我们将平衡因子绝对值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的节点称为“失衡节点”。根据节点失衡情况的不同，旋转操作分为四种：右旋、左旋、先右旋后左旋、先左旋后右旋。下面详细介绍这些旋转操作。</p><h3 id="右旋">右旋</h3><p>如下图所示，节点下方为平衡因子。从底至顶看，二叉树中首个失衡节点是“节点 3”。我们关注以该失衡节点为根节点的子树，将该节点记为 <code>node</code> ，其左子节点记为 <code>child</code> ，执行“右旋”操作。完成右旋后，子树恢复平衡，并且仍然保持二叉搜索树的性质。</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">右旋 1</button><button type="button" class="tab">右旋 2</button><button type="button" class="tab">右旋 3</button><button type="button" class="tab">右旋 4</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/973716ad/avltree_right_rotate_step1.png" alt="右旋操作步骤"></p></div><div class="tab-item-content"><p><img src="/posts/973716ad/avltree_right_rotate_step2.png" alt="avltree_right_rotate_step2"></p></div><div class="tab-item-content"><p><img src="/posts/973716ad/avltree_right_rotate_step3.png" alt="avltree_right_rotate_step3"></p></div><div class="tab-item-content"><p><img src="/posts/973716ad/avltree_right_rotate_step4.png" alt="avltree_right_rotate_step4"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>如下图所示，当节点 <code>child</code> 有右子节点（记为 <code>grand_child</code> ）时，需要在右旋中添加一步：将 <code>grand_child</code> 作为 <code>node</code> 的左子节点。</p><p><img src="/posts/973716ad/avltree_right_rotate_with_grandchild.png" alt="有 grand_child 的右旋操作"></p><p>“向右旋转”是一种形象化的说法，实际上需要通过修改节点指针来实现，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">right_rotate</span>(<span class="params">self, node: TreeNode | <span class="literal">None</span></span>) -&gt; TreeNode | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;右旋操作&quot;&quot;&quot;</span></span><br><span class="line">    child = node.left</span><br><span class="line">    grand_child = child.right</span><br><span class="line">    <span class="comment"># 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child.right = node</span><br><span class="line">    node.left = grand_child</span><br><span class="line">    <span class="comment"># 更新节点高度</span></span><br><span class="line">    <span class="variable language_">self</span>.update_height(node)</span><br><span class="line">    <span class="variable language_">self</span>.update_height(child)</span><br><span class="line">    <span class="comment"># 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child</span><br></pre></td></tr></table></figure><h3 id="左旋">左旋</h3><p>相应地，如果考虑上述失衡二叉树的“镜像”，则需要执行下图所示的“左旋”操作。</p><p><img src="/posts/973716ad/avltree_left_rotate.png" alt="左旋操作"></p><p>同理，如下图所示，当节点 <code>child</code> 有左子节点（记为 <code>grand_child</code> ）时，需要在左旋中添加一步：将 <code>grand_child</code> 作为 <code>node</code> 的右子节点。</p><p><img src="/posts/973716ad/avltree_left_rotate_with_grandchild.png" alt="有 grand_child 的左旋操作"></p><p>可以观察到，<strong>右旋和左旋操作在逻辑上是镜像对称的，它们分别解决的两种失衡情况也是对称的</strong>。基于对称性，我们只需将右旋的实现代码中的所有的 <code>left</code> 替换为 <code>right</code> ，将所有的 <code>right</code> 替换为 <code>left</code> ，即可得到左旋的实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">left_rotate</span>(<span class="params">self, node: TreeNode | <span class="literal">None</span></span>) -&gt; TreeNode | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;左旋操作&quot;&quot;&quot;</span></span><br><span class="line">    child = node.right</span><br><span class="line">    grand_child = child.left</span><br><span class="line">    <span class="comment"># 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child.left = node</span><br><span class="line">    node.right = grand_child</span><br><span class="line">    <span class="comment"># 更新节点高度</span></span><br><span class="line">    <span class="variable language_">self</span>.update_height(node)</span><br><span class="line">    <span class="variable language_">self</span>.update_height(child)</span><br><span class="line">    <span class="comment"># 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child</span><br></pre></td></tr></table></figure><h3 id="先左旋后右旋">先左旋后右旋</h3><p>对于下图中的失衡节点 3 ，仅使用左旋或右旋都无法使子树恢复平衡。此时需要先对 <code>child</code> 执行“左旋”，再对 <code>node</code> 执行“右旋”。</p><p><img src="/posts/973716ad/avltree_left_right_rotate.png" alt="先左旋后右旋"></p><h3 id="先右旋后左旋">先右旋后左旋</h3><p>如下图所示，对于上述失衡二叉树的镜像情况，需要先对 <code>child</code> 执行“右旋”，再对 <code>node</code> 执行“左旋”。</p><p><img src="/posts/973716ad/avltree_right_left_rotate.png" alt="先右旋后左旋"></p><h3 id="旋转的选择">旋转的选择</h3><p>下图展示的四种失衡情况与上述案例逐个对应，分别需要采用右旋、先左旋后右旋、先右旋后左旋、左旋的操作。</p><p><img src="/posts/973716ad/avltree_rotation_cases.png" alt="AVL 树的四种旋转情况"></p><p>如下表所示，我们通过判断失衡节点的平衡因子以及较高一侧子节点的平衡因子的正负号，来确定失衡节点属于上图中的哪种情况。</p><p align="center"> 表 <id> &nbsp; 四种旋转情况的选择条件 </id></p><table><thead><tr><th>失衡节点的平衡因子</th><th>子节点的平衡因子</th><th>应采用的旋转方法</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> （左偏树）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></td><td>右旋</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> （左偏树）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></td><td>先左旋后右旋</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&lt; -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> （右偏树）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></td><td>左旋</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&lt; -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> （右偏树）</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></td><td>先右旋后左旋</td></tr></tbody></table><p>为了便于使用，我们将旋转操作封装成一个函数。<strong>有了这个函数，我们就能对各种失衡情况进行旋转，使失衡节点重新恢复平衡</strong>。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, node: TreeNode | <span class="literal">None</span></span>) -&gt; TreeNode | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;执行旋转操作，使该子树重新恢复平衡&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取节点 node 的平衡因子</span></span><br><span class="line">    balance_factor = <span class="variable language_">self</span>.balance_factor(node)</span><br><span class="line">    <span class="comment"># 左偏树</span></span><br><span class="line">    <span class="keyword">if</span> balance_factor &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.balance_factor(node.left) &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 右旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.right_rotate(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 先左旋后右旋</span></span><br><span class="line">            node.left = <span class="variable language_">self</span>.left_rotate(node.left)</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.right_rotate(node)</span><br><span class="line">    <span class="comment"># 右偏树</span></span><br><span class="line">    <span class="keyword">elif</span> balance_factor &lt; -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.balance_factor(node.right) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 左旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.left_rotate(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 先右旋后左旋</span></span><br><span class="line">            node.right = <span class="variable language_">self</span>.right_rotate(node.right)</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.left_rotate(node)</span><br><span class="line">    <span class="comment"># 平衡树，无须旋转，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><h2 id="AVL-树常用操作">AVL 树常用操作</h2><h3 id="插入节点">插入节点</h3><p>AVL 树的节点插入操作与二叉搜索树在主体上类似。唯一的区别在于，在 AVL 树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。因此，<strong>我们需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡</strong>。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;插入节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="variable language_">self</span>._root = <span class="variable language_">self</span>.insert_helper(<span class="variable language_">self</span>._root, val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_helper</span>(<span class="params">self, node: TreeNode | <span class="literal">None</span>, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;递归插入节点（辅助方法）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">    <span class="comment"># 1. 查找插入位置并插入节点</span></span><br><span class="line">    <span class="keyword">if</span> val &lt; node.val:</span><br><span class="line">        node.left = <span class="variable language_">self</span>.insert_helper(node.left, val)</span><br><span class="line">    <span class="keyword">elif</span> val &gt; node.val:</span><br><span class="line">        node.right = <span class="variable language_">self</span>.insert_helper(node.right, val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 重复节点不插入，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="comment"># 更新节点高度</span></span><br><span class="line">    <span class="variable language_">self</span>.update_height(node)</span><br><span class="line">    <span class="comment"># 2. 执行旋转操作，使该子树重新恢复平衡</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.rotate(node)</span><br></pre></td></tr></table></figure><h3 id="删除节点">删除节点</h3><p>类似地，在二叉搜索树的删除节点方法的基础上，需要从底至顶执行旋转操作，使所有失衡节点恢复平衡。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;删除节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="variable language_">self</span>._root = <span class="variable language_">self</span>.remove_helper(<span class="variable language_">self</span>._root, val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_helper</span>(<span class="params">self, node: TreeNode | <span class="literal">None</span>, val: <span class="built_in">int</span></span>) -&gt; TreeNode | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;递归删除节点（辅助方法）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 1. 查找节点并删除</span></span><br><span class="line">    <span class="keyword">if</span> val &lt; node.val:</span><br><span class="line">        node.left = <span class="variable language_">self</span>.remove_helper(node.left, val)</span><br><span class="line">    <span class="keyword">elif</span> val &gt; node.val:</span><br><span class="line">        node.right = <span class="variable language_">self</span>.remove_helper(node.right, val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            child = node.left <span class="keyword">or</span> node.right</span><br><span class="line">            <span class="comment"># 子节点数量 = 0 ，直接删除 node 并返回</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 子节点数量 = 1 ，直接删除 node</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点</span></span><br><span class="line">            temp = node.right</span><br><span class="line">            <span class="keyword">while</span> temp.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                temp = temp.left</span><br><span class="line">            node.right = <span class="variable language_">self</span>.remove_helper(node.right, temp.val)</span><br><span class="line">            node.val = temp.val</span><br><span class="line">    <span class="comment"># 更新节点高度</span></span><br><span class="line">    <span class="variable language_">self</span>.update_height(node)</span><br><span class="line">    <span class="comment"># 2. 执行旋转操作，使该子树重新恢复平衡</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.rotate(node)</span><br></pre></td></tr></table></figure><h3 id="查找节点">查找节点</h3><p>AVL 树的节点查找操作与二叉搜索树一致，在此不再赘述。</p><h2 id="AVL-树典型应用">AVL 树典型应用</h2><ul><li>组织和存储大型数据，适用于高频查找、低频增删的场景。</li><li>用于构建数据库中的索引系统。</li><li>红黑树也是一种常见的平衡二叉搜索树。相较于 AVL 树，红黑树的平衡条件更宽松，插入与删除节点所需的旋转操作更少，节点增删操作的平均效率更高。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;AVL 树 *&lt;/h1&gt;
&lt;p&gt;在“二叉搜索树”章节中我们提到，在多次插入和删除操作后，二叉搜索树可能退化为链表。在这种情况下，所有操作的时间复杂度将从 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
    
    <category term="AVL树" scheme="https://chaoleweisi.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://chaoleweisi.github.io/posts/7cab1e06/"/>
    <id>https://chaoleweisi.github.io/posts/7cab1e06/</id>
    <published>2024-10-13T04:25:14.000Z</published>
    <updated>2024-10-14T07:17:47.324Z</updated>
    
    <content type="html"><![CDATA[<h1>二叉搜索树</h1><p>如下图所示，<u>二叉搜索树（binary search tree）</u>满足以下条件。</p><ol><li>对于根节点，左子树中所有节点的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 根节点的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 右子树中所有节点的值。</li><li>任意节点的左、右子树也是二叉搜索树，即同样满足条件 <code>1.</code> 。</li></ol><p><img src="/posts/7cab1e06/binary_search_tree.png" alt="二叉搜索树"></p><h2 id="二叉搜索树的操作">二叉搜索树的操作</h2><p>我们将二叉搜索树封装为一个类 <code>BinarySearchTree</code> ，并声明一个成员变量 <code>root</code> ，指向树的根节点。</p><h3 id="查找节点">查找节点</h3><p>给定目标节点值 <code>num</code> ，可以根据二叉搜索树的性质来查找。如下图所示，我们声明一个节点 <code>cur</code> ，从二叉树的根节点 <code>root</code> 出发，循环比较节点值 <code>cur.val</code> 和 <code>num</code> 之间的大小关系。</p><ul><li>若 <code>cur.val &lt; num</code> ，说明目标节点在 <code>cur</code> 的右子树中，因此执行 <code>cur = cur.right</code> 。</li><li>若 <code>cur.val &gt; num</code> ，说明目标节点在 <code>cur</code> 的左子树中，因此执行 <code>cur = cur.left</code> 。</li><li>若 <code>cur.val = num</code> ，说明找到目标节点，跳出循环并返回该节点。</li></ul><p><strong>二叉搜索树查找节点示例</strong></p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">tab 1</button><button type="button" class="tab">tab 2</button><button type="button" class="tab">tab 3</button><button type="button" class="tab">tab 4</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/7cab1e06/bst_search_step1.png" alt="二叉搜索树查找节点示例"></p></div><div class="tab-item-content"><p><img src="/posts/7cab1e06/bst_search_step2.png" alt="bst_search_step2"></p></div><div class="tab-item-content"><p><img src="/posts/7cab1e06/bst_search_step3.png" alt="bst_search_step3"></p></div><div class="tab-item-content"><p><img src="/posts/7cab1e06/bst_search_step4.png" alt="bst_search_step4"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; TreeNode | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查找节点&quot;&quot;&quot;</span></span><br><span class="line">    cur = <span class="variable language_">self</span>._root</span><br><span class="line">    <span class="comment"># 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 目标节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; num:</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="comment"># 目标节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">elif</span> cur.val &gt; num:</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="comment"># 找到目标节点，跳出循环</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h3 id="插入节点">插入节点</h3><p>给定一个待插入元素 <code>num</code> ，为了保持二叉搜索树“左子树 &lt; 根节点 &lt; 右子树”的性质，插入操作流程如下图所示。</p><ol><li><strong>查找插入位置</strong>：与查找操作相似，从根节点出发，根据当前节点值和 <code>num</code> 的大小关系循环向下搜索，直到越过叶节点（遍历至 <code>None</code> ）时跳出循环。</li><li><strong>在该位置插入节点</strong>：初始化节点 <code>num</code> ，将该节点置于 <code>None</code> 的位置。</li></ol><p><img src="/posts/7cab1e06/bst_insert.png" alt="在二叉搜索树中插入节点"></p><p>在代码实现中，需要注意以下两点。</p><ul><li>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。</li><li>为了实现插入节点，我们需要借助节点 <code>pre</code> 保存上一轮循环的节点。这样在遍历至 <code>None</code> 时，我们可以获取到其父节点，从而完成节点插入操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, num: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;插入节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 若树为空，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._root = TreeNode(num)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 循环查找，越过叶节点后跳出</span></span><br><span class="line">    cur, pre = <span class="variable language_">self</span>._root, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> cur.val == num:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="comment"># 插入位置在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; num:</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="comment"># 插入位置在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.left</span><br><span class="line">    <span class="comment"># 插入节点</span></span><br><span class="line">    node = TreeNode(num)</span><br><span class="line">    <span class="keyword">if</span> pre.val &lt; num:</span><br><span class="line">        pre.right = node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pre.left = node</span><br></pre></td></tr></table></figure><p>与查找节点相同，插入节点使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间。</p><h3 id="删除节点">删除节点</h3><p>先在二叉树中查找到目标节点，再将其删除。与插入节点类似，我们需要保证在删除操作完成后，二叉搜索树的“左子树 &lt; 根节点 &lt; 右子树”的性质仍然满足。因此，我们根据目标节点的子节点数量，分 0、1 和 2 三种情况，执行对应的删除节点操作。</p><p>如下图所示，当待删除节点的度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，表示该节点是叶节点，可以直接删除。</p><p><img src="/posts/7cab1e06/bst_remove_case1.png" alt="在二叉搜索树中删除节点（度为 0 ）"></p><p>如下图所示，当待删除节点的度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时，将待删除节点替换为其子节点即可。</p><p><img src="/posts/7cab1e06/bst_remove_case2.png" alt="在二叉搜索树中删除节点（度为 1 ）"></p><p>当待删除节点的度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左子树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 根节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 右子树”的性质，<strong>因此这个节点可以是右子树的最小节点或左子树的最大节点</strong>。</p><p>假设我们选择右子树的最小节点（中序遍历的下一个节点），则删除操作流程如下图所示。</p><ol><li>找到待删除节点在“中序遍历序列”中的下一个节点，记为 <code>tmp</code> 。</li><li>用 <code>tmp</code> 的值覆盖待删除节点的值，并在树中递归删除节点 <code>tmp</code> 。</li></ol><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">tab 1</button><button type="button" class="tab">tab 2</button><button type="button" class="tab">tab 3</button><button type="button" class="tab">tab 4</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/7cab1e06/bst_remove_case3_step1.png" alt="在二叉搜索树中删除节点（度为 2 ）"></p></div><div class="tab-item-content"><p><img src="/posts/7cab1e06/bst_remove_case3_step2.png" alt="bst_remove_case3_step2"></p></div><div class="tab-item-content"><p><img src="/posts/7cab1e06/bst_remove_case3_step3.png" alt="bst_remove_case3_step3"></p></div><div class="tab-item-content"><p><img src="/posts/7cab1e06/bst_remove_case3_step4.png" alt="bst_remove_case3_step4"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>删除节点操作同样使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间，其中查找待删除节点需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间，获取中序遍历后继节点需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, num: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;删除节点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 循环查找，越过叶节点后跳出</span></span><br><span class="line">    cur, pre = <span class="variable language_">self</span>._root, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> cur.val == num:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="comment"># 待删除节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; num:</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="comment"># 待删除节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.left</span><br><span class="line">    <span class="comment"># 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子节点数量 = 0 or 1</span></span><br><span class="line">    <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> cur.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 当子节点数量 = 0 / 1 时， child = null / 该子节点</span></span><br><span class="line">        child = cur.left <span class="keyword">or</span> cur.right</span><br><span class="line">        <span class="comment"># 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> cur != <span class="variable language_">self</span>._root:</span><br><span class="line">            <span class="keyword">if</span> pre.left == cur:</span><br><span class="line">                pre.left = child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.right = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 若删除节点为根节点，则重新指定根节点</span></span><br><span class="line">            <span class="variable language_">self</span>._root = child</span><br><span class="line">    <span class="comment"># 子节点数量 = 2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 获取中序遍历中 cur 的下一个节点</span></span><br><span class="line">        tmp: TreeNode = cur.right</span><br><span class="line">        <span class="keyword">while</span> tmp.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            tmp = tmp.left</span><br><span class="line">        <span class="comment"># 递归删除节点 tmp</span></span><br><span class="line">        <span class="variable language_">self</span>.remove(tmp.val)</span><br><span class="line">        <span class="comment"># 用 tmp 覆盖 cur</span></span><br><span class="line">        cur.val = tmp.val</span><br></pre></td></tr></table></figure><h3 id="中序遍历有序">中序遍历有序</h3><p>如下图所示，二叉树的中序遍历遵循“左 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 根 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 右”的遍历顺序，而二叉搜索树满足“左子节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 根节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 右子节点”的大小关系。</p><p>这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：<strong>二叉搜索树的中序遍历序列是升序的</strong>。</p><p>利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间，无须进行额外的排序操作，非常高效。</p><p><img src="/posts/7cab1e06/bst_inorder_traversal.png" alt="二叉搜索树的中序遍历序列"></p><h2 id="二叉搜索树的效率">二叉搜索树的效率</h2><p>给定一组数据，我们考虑使用数组或二叉搜索树存储。观察下表，二叉搜索树的各项操作的时间复杂度都是对数阶，具有稳定且高效的性能。只有在高频添加、低频查找删除数据的场景下，数组比二叉搜索树的效率更高。</p><p align="center"> 表 <id> &nbsp; 数组与搜索树的效率对比 </id></p><table><thead><tr><th></th><th>无序数组</th><th>二叉搜索树</th></tr></thead><tbody><tr><td>查找元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>插入元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>删除元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><p>在理想情况下，二叉搜索树是“平衡”的，这样就可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span> 轮循环内查找任意节点。</p><p>然而，如果我们在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为下图所示的链表，这时各种操作的时间复杂度也会退化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><p><img src="/posts/7cab1e06/bst_degradation.png" alt="二叉搜索树退化"></p><h2 id="二叉搜索树常见应用">二叉搜索树常见应用</h2><ul><li>用作系统中的多级索引，实现高效的查找、插入、删除操作。</li><li>作为某些搜索算法的底层数据结构。</li><li>用于存储数据流，以保持其有序状态。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;二叉搜索树&lt;/h1&gt;
&lt;p&gt;如下图所示，&lt;u&gt;二叉搜索树（binary search tree）&lt;/u&gt;满足以下条件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于根节点，左子树中所有节点的值 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://chaoleweisi.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树数组表示</title>
    <link href="https://chaoleweisi.github.io/posts/1d6d7c24/"/>
    <id>https://chaoleweisi.github.io/posts/1d6d7c24/</id>
    <published>2024-10-13T04:24:14.000Z</published>
    <updated>2024-10-14T07:07:39.419Z</updated>
    
    <content type="html"><![CDATA[<h1>二叉树数组表示</h1><p>在链表表示下，二叉树的存储单元为节点 <code>TreeNode</code> ，节点之间通过指针相连接。上一节介绍了链表表示下的二叉树的各项基本操作。</p><p>那么，我们能否用数组来表示二叉树呢？答案是肯定的。</p><h2 id="表示完美二叉树">表示完美二叉树</h2><p>先分析一个简单案例。给定一棵完美二叉树，我们将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一的数组索引。</p><p>根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：<strong>若某节点的索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，则该节点的左子节点索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，右子节点索引为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2i + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></strong> 。下图展示了各个节点索引之间的映射关系。</p><p><img src="/posts/1d6d7c24/array_representation_binary_tree.png" alt="完美二叉树的数组表示"></p><p><strong>映射公式的角色相当于链表中的节点引用（指针）</strong>。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的左（右）子节点。</p><h2 id="表示任意二叉树">表示任意二叉树</h2><p>完美二叉树是一个特例，在二叉树的中间层通常存在许多 <code>None</code> 。由于层序遍历序列并不包含这些 <code>None</code> ，因此我们无法仅凭该序列来推测 <code>None</code> 的数量和分布位置。<strong>这意味着存在多种二叉树结构都符合该层序遍历序列</strong>。</p><p>如下图所示，给定一棵非完美二叉树，上述数组表示方法已经失效。</p><p><img src="/posts/1d6d7c24/array_representation_without_empty.png" alt="层序遍历序列对应多种二叉树可能性"></p><p>为了解决此问题，<strong>我们可以考虑在层序遍历序列中显式地写出所有 <code>None</code></strong> 。如下图所示，这样处理后，层序遍历序列就可以唯一表示二叉树了。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二叉树的数组表示</span></span><br><span class="line"><span class="comment"># 使用 None 来表示空位</span></span><br><span class="line">tree = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="literal">None</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">12</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">15</span>]</span><br></pre></td></tr></table></figure><p><img src="/posts/1d6d7c24/array_representation_with_empty.png" alt="任意类型二叉树的数组表示"></p><p>值得说明的是，<strong>完全二叉树非常适合使用数组来表示</strong>。回顾完全二叉树的定义，<code>None</code> 只出现在最底层且靠右的位置，<strong>因此所有 <code>None</code> 一定出现在层序遍历序列的末尾</strong>。</p><p>这意味着使用数组表示完全二叉树时，可以省略存储所有 <code>None</code> ，非常方便。下图给出了一个例子。</p><p><img src="/posts/1d6d7c24/array_representation_complete_binary_tree.png" alt="完全二叉树的数组表示"></p><p>以下代码实现了一棵基于数组表示的二叉树，包括以下几种操作。</p><ul><li>给定某节点，获取它的值、左（右）子节点、父节点。</li><li>获取前序遍历、中序遍历、后序遍历、层序遍历序列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数组表示下的二叉树类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arr: <span class="built_in">list</span>[<span class="built_in">int</span> | <span class="literal">None</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._tree = <span class="built_in">list</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;列表容量&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._tree)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">val</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span> | <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取索引为 i 节点的值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 若索引越界，则返回 None ，代表空位</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="variable language_">self</span>.size():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._tree[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">left</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span> | <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取索引为 i 节点的左子节点的索引&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">right</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span> | <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取索引为 i 节点的右子节点的索引&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span> | <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取索引为 i 节点的父节点的索引&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">level_order</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;层序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="comment"># 直接遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.size()):</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.val(i) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.val(i))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, i: <span class="built_in">int</span>, order: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;深度优先遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.val(i) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> order == <span class="string">&quot;pre&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.val(i))</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="variable language_">self</span>.left(i), order)</span><br><span class="line">        <span class="comment"># 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> order == <span class="string">&quot;in&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.val(i))</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="variable language_">self</span>.right(i), order)</span><br><span class="line">        <span class="comment"># 后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> order == <span class="string">&quot;post&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.val(i))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pre_order</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;前序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="number">0</span>, order=<span class="string">&quot;pre&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_order</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="number">0</span>, order=<span class="string">&quot;in&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post_order</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;后序遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="number">0</span>, order=<span class="string">&quot;post&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化二叉树</span></span><br><span class="line">    <span class="comment"># 这里借助了一个从数组直接生成二叉树的函数</span></span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="literal">None</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">12</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">15</span>]</span><br><span class="line">    root = list_to_tree(arr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n初始化二叉树\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;二叉树的数组表示：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(arr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;二叉树的链表表示：&quot;</span>)</span><br><span class="line">    print_tree(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数组表示下的二叉树类</span></span><br><span class="line">    abt = ArrayBinaryTree(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问节点</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    l, r, p = abt.left(i), abt.right(i), abt.parent(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n当前节点的索引为 <span class="subst">&#123;i&#125;</span> ，值为 <span class="subst">&#123;abt.val(i)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;其左子节点的索引为 <span class="subst">&#123;l&#125;</span> ，值为 <span class="subst">&#123;abt.val(l)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;其右子节点的索引为 <span class="subst">&#123;r&#125;</span> ，值为 <span class="subst">&#123;abt.val(r)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;其父节点的索引为 <span class="subst">&#123;p&#125;</span> ，值为 <span class="subst">&#123;abt.val(p)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历树</span></span><br><span class="line">    res = abt.level_order()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n层序遍历为：&quot;</span>, res)</span><br><span class="line">    res = abt.pre_order()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;前序遍历为：&quot;</span>, res)</span><br><span class="line">    res = abt.in_order()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;中序遍历为：&quot;</span>, res)</span><br><span class="line">    res = abt.post_order()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;后序遍历为：&quot;</span>, res)</span><br></pre></td></tr></table></figure><h2 id="优点与局限性">优点与局限性</h2><p>二叉树的数组表示主要有以下优点。</p><ul><li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。</li><li>不需要存储指针，比较节省空间。</li><li>允许随机访问节点。</li></ul><p>然而，数组表示也存在一些局限性。</p><ul><li>数组存储需要连续内存空间，因此不适合存储数据量过大的树。</li><li>增删节点需要通过数组插入与删除操作实现，效率较低。</li><li>当二叉树中存在大量 <code>None</code> 时，数组中包含的节点数据比重较低，空间利用率较低。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;二叉树数组表示&lt;/h1&gt;
&lt;p&gt;在链表表示下，二叉树的存储单元为节点 &lt;code&gt;TreeNode&lt;/code&gt; ，节点之间通过指针相连接。上一节介绍了链表表示下的二叉树的各项基本操作。&lt;/p&gt;
&lt;p&gt;那么，我们能否用数组来表示二叉树呢？答案是肯定的。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://chaoleweisi.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="https://chaoleweisi.github.io/posts/b9b9f7e7/"/>
    <id>https://chaoleweisi.github.io/posts/b9b9f7e7/</id>
    <published>2024-10-13T04:23:14.000Z</published>
    <updated>2024-10-14T07:13:14.926Z</updated>
    
    <content type="html"><![CDATA[<h1>二叉树遍历</h1><p>从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。</p><p>二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等。</p><h2 id="层序遍历">层序遍历</h2><p>如下图所示，<u>层序遍历（level-order traversal）</u>从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。</p><p>层序遍历本质上属于<u>广度优先遍历（breadth-first traversal）</u>，也称<u>广度优先搜索（breadth-first search, BFS）</u>，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。</p><p><img src="/posts/b9b9f7e7/binary_tree_bfs.png" alt="二叉树的层序遍历"></p><h3 id="代码实现">代码实现</h3><p>广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;层序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化队列，加入根节点</span></span><br><span class="line">    queue: deque[TreeNode] = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="comment"># 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node: TreeNode = queue.popleft()  <span class="comment"># 队列出队</span></span><br><span class="line">        res.append(node.val)  <span class="comment"># 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(node.left)  <span class="comment"># 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(node.right)  <span class="comment"># 右子节点入队</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化二叉树</span></span><br><span class="line">    <span class="comment"># 这里借助了一个从数组直接生成二叉树的函数</span></span><br><span class="line">    root: TreeNode = list_to_tree(arr=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n初始化二叉树\n&quot;</span>)</span><br><span class="line">    print_tree(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 层序遍历</span></span><br><span class="line">    res: <span class="built_in">list</span>[<span class="built_in">int</span>] = level_order(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n层序遍历的节点打印序列 = &quot;</span>, res)</span><br></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析</h3><ul><li><strong>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong> ：所有节点被访问一次，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 为节点数量。</li><li><strong>空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong> ：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n + 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span> 个节点，占用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 空间。</li></ul><h2 id="前序、中序、后序遍历">前序、中序、后序遍历</h2><p>相应地，前序、中序和后序遍历都属于<u>深度优先遍历（depth-first traversal）</u>，也称<u>深度优先搜索（depth-first search, DFS）</u>，它体现了一种“先走到尽头，再回溯继续”的遍历方式。</p><p>下图展示了对二叉树进行深度优先遍历的工作原理。<strong>深度优先遍历就像是绕着整棵二叉树的外围“走”一圈</strong>，在每个节点都会遇到三个位置，分别对应前序遍历、中序遍历和后序遍历。</p><p><img src="/posts/b9b9f7e7/binary_tree_dfs.png" alt="二叉搜索树的前序、中序、后序遍历"></p><h3 id="代码实现-2">代码实现</h3><p>深度优先搜索通常基于递归实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pre_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;前序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    res.append(root.val)</span><br><span class="line">    pre_order(root=root.left)</span><br><span class="line">    pre_order(root=root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">in_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;中序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    in_order(root=root.left)</span><br><span class="line">    res.append(root.val)</span><br><span class="line">    in_order(root=root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_order</span>(<span class="params">root: TreeNode | <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;后序遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    post_order(root=root.left)</span><br><span class="line">    post_order(root=root.right)</span><br><span class="line">    res.append(root.val)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化二叉树</span></span><br><span class="line">    <span class="comment"># 这里借助了一个从数组直接生成二叉树的函数</span></span><br><span class="line">    root = list_to_tree(arr=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n初始化二叉树\n&quot;</span>)</span><br><span class="line">    print_tree(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前序遍历</span></span><br><span class="line">    res = []</span><br><span class="line">    pre_order(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n前序遍历的节点打印序列 = &quot;</span>, res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">    res.clear()</span><br><span class="line">    in_order(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n中序遍历的节点打印序列 = &quot;</span>, res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 后序遍历</span></span><br><span class="line">    res.clear()</span><br><span class="line">    post_order(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n后序遍历的节点打印序列 = &quot;</span>, res)</span><br></pre></td></tr></table></figure><pre><code>深度优先搜索也可以基于迭代实现，有兴趣的读者可以自行研究。</code></pre><p>下图展示了前序遍历二叉树的递归过程，其可分为“递”和“归”两个逆向的部分。</p><ol><li>“递”表示开启新方法，程序在此过程中访问下一个节点。</li><li>“归”表示函数返回，代表当前节点已经访问完毕。</li></ol><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">tab 1</button><button type="button" class="tab">tab 2</button><button type="button" class="tab">tab 3</button><button type="button" class="tab">tab 4</button><button type="button" class="tab">tab 5</button><button type="button" class="tab">tab 6</button><button type="button" class="tab">tab 7</button><button type="button" class="tab">tab 8</button><button type="button" class="tab">tab 9</button><button type="button" class="tab">tab 10</button><button type="button" class="tab">tab 11</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/b9b9f7e7/preorder_step1.png" alt="前序遍历的递归过程"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step2.png" alt="preorder_step2"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step3.png" alt="preorder_step3"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step4.png" alt="preorder_step4"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step5.png" alt="preorder_step5"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step6.png" alt="preorder_step6"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step7.png" alt="preorder_step7"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step8.png" alt="preorder_step8"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step9.png" alt="preorder_step9"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step10.png" alt="preorder_step10"></p></div><div class="tab-item-content"><p><img src="/posts/b9b9f7e7/preorder_step11.png" alt="preorder_step11"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="复杂度分析-2">复杂度分析</h3><ul><li><strong>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong> ：所有节点被访问一次，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间。</li><li><strong>空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong> ：在最差情况下，即树退化为链表时，递归深度达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，系统占用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 栈帧空间。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;二叉树遍历&lt;/h1&gt;
&lt;p&gt;从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。&lt;/p&gt;
&lt;p&gt;二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://chaoleweisi.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://chaoleweisi.github.io/posts/e85d694a/"/>
    <id>https://chaoleweisi.github.io/posts/e85d694a/</id>
    <published>2024-10-13T04:20:14.000Z</published>
    <updated>2024-10-14T07:18:01.119Z</updated>
    
    <content type="html"><![CDATA[<h1>二叉树</h1><p><u>二叉树（binary tree）</u>是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二叉树节点类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val: <span class="built_in">int</span> = val                <span class="comment"># 节点值</span></span><br><span class="line">        <span class="variable language_">self</span>.left: TreeNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 左子节点引用</span></span><br><span class="line">        <span class="variable language_">self</span>.right: TreeNode | <span class="literal">None</span> = <span class="literal">None</span> <span class="comment"># 右子节点引用</span></span><br></pre></td></tr></table></figure><p>每个节点都有两个引用（指针），分别指向<u>左子节点（left-child node）</u>和<u>右子节点（right-child node）</u>，该节点被称为这两个子节点的<u>父节点（parent node）</u>。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的<u>左子树（left subtree）</u>，同理可得<u>右子树（right subtree）</u>。</p><p><strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树</strong>。如下图所示，如果将“节点 2”视为父节点，则其左子节点和右子节点分别是“节点 4”和“节点 5”，左子树是“节点 4 及其以下节点形成的树”，右子树是“节点 5 及其以下节点形成的树”。</p><p><img src="/posts/e85d694a/binary_tree_definition.png" alt="父节点、子节点、子树"></p><h2 id="二叉树常见术语">二叉树常见术语</h2><p>二叉树的常用术语如下图所示。</p><ul><li><u>根节点（root node）</u>：位于二叉树顶层的节点，没有父节点。</li><li><u>叶节点（leaf node）</u>：没有子节点的节点，其两个指针均指向 <code>None</code> 。</li><li><u>边（edge）</u>：连接两个节点的线段，即节点引用（指针）。</li><li>节点所在的<u>层（level）</u>：从顶至底递增，根节点所在层为 1 。</li><li>节点的<u>度（degree）</u>：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</li><li>二叉树的<u>高度（height）</u>：从根节点到最远叶节点所经过的边的数量。</li><li>节点的<u>深度（depth）</u>：从根节点到该节点所经过的边的数量。</li><li>节点的<u>高度（height）</u>：从距离该节点最远的叶节点到该节点所经过的边的数量。</li></ul><p><img src="/posts/e85d694a/binary_tree_terminology.png" alt="二叉树的常用术语"></p><pre><code>请注意，我们通常将“高度”和“深度”定义为“经过的边的数量”，但有些题目或教材可能会将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要加 1 。</code></pre><h2 id="二叉树基本操作">二叉树基本操作</h2><h3 id="初始化二叉树">初始化二叉树</h3><p>与链表类似，首先初始化节点，然后构建引用（指针）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化二叉树</span></span><br><span class="line"><span class="comment"># 初始化节点</span></span><br><span class="line">n1 = TreeNode(val=<span class="number">1</span>)</span><br><span class="line">n2 = TreeNode(val=<span class="number">2</span>)</span><br><span class="line">n3 = TreeNode(val=<span class="number">3</span>)</span><br><span class="line">n4 = TreeNode(val=<span class="number">4</span>)</span><br><span class="line">n5 = TreeNode(val=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 构建节点之间的引用（指针）</span></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br></pre></td></tr></table></figure><h3 id="插入与删除节点">插入与删除节点</h3><p>与链表类似，在二叉树中插入与删除节点可以通过修改指针来实现。下图给出了一个示例。</p><p><img src="/posts/e85d694a/binary_tree_add_remove.png" alt="在二叉树中插入与删除节点"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入与删除节点</span></span><br><span class="line">p = TreeNode(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 在 n1 -&gt; n2 中间插入节点 P</span></span><br><span class="line">n1.left = p</span><br><span class="line">p.left = n2</span><br><span class="line"><span class="comment"># 删除节点 P</span></span><br><span class="line">n1.left = n2</span><br></pre></td></tr></table></figure><pre><code>需要注意的是，插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除通常是由一套操作配合完成的，以实现有实际意义的操作。</code></pre><h2 id="常见二叉树类型">常见二叉树类型</h2><h3 id="完美二叉树">完美二叉树</h3><p>如下图所示，<u>完美二叉树（perfect binary tree）</u>所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ，其余所有节点的度都为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> ；若树的高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> ，则节点总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{h+1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。</p><pre><code>请注意，在中文社区中，完美二叉树常被称为&lt;u&gt;满二叉树&lt;/u&gt;。</code></pre><p><img src="/posts/e85d694a/perfect_binary_tree.png" alt="完美二叉树"></p><h3 id="完全二叉树">完全二叉树</h3><p>如下图所示，<u>完全二叉树（complete binary tree）</u>只有最底层的节点未被填满，且最底层节点尽量靠左填充。请注意，完美二叉树也是一棵完全二叉树。</p><p><img src="/posts/e85d694a/complete_binary_tree.png" alt="完全二叉树"></p><h3 id="完满二叉树">完满二叉树</h3><p>如下图所示，<u>完满二叉树（full binary tree）</u>除了叶节点之外，其余所有节点都有两个子节点。</p><p><img src="/posts/e85d694a/full_binary_tree.png" alt="完满二叉树"></p><h3 id="平衡二叉树">平衡二叉树</h3><p>如下图所示，<u>平衡二叉树（balanced binary tree）</u>中任意节点的左子树和右子树的高度之差的绝对值不超过 1 。</p><p><img src="/posts/e85d694a/balanced_binary_tree.png" alt="平衡二叉树"></p><h2 id="二叉树的退化">二叉树的退化</h2><p>下图展示了二叉树的理想结构与退化结构。当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。</p><ul><li>完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。</li><li>链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</li></ul><p><img src="/posts/e85d694a/binary_tree_best_worst_cases.png" alt="二叉树的最佳结构与最差结构"></p><p>如下表所示，在最佳结构和最差结构下，二叉树的叶节点数量、节点总数、高度等达到极大值或极小值。</p><p align="center"> 表 <id> &nbsp; 二叉树的最佳结构与最差结构 </id></p><table><thead><tr><th></th><th>完美二叉树</th><th>链表</th></tr></thead><tbody><tr><td>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 层的节点数量</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td></tr><tr><td>高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 的树的叶节点数量</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td></tr><tr><td>高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 的树的节点总数</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{h+1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td></tr><tr><td>节点总数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的树的高度</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\log_2 (n+1) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;二叉树&lt;/h1&gt;
&lt;p&gt;&lt;u&gt;二叉树（binary tree）&lt;/u&gt;是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://chaoleweisi.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈希——小结</title>
    <link href="https://chaoleweisi.github.io/posts/6367708d/"/>
    <id>https://chaoleweisi.github.io/posts/6367708d/</id>
    <published>2024-10-13T03:51:14.000Z</published>
    <updated>2024-10-14T06:27:31.753Z</updated>
    
    <content type="html"><![CDATA[<h1>小结</h1><h3 id="重点回顾">重点回顾</h3><ul><li>输入 <code>key</code> ，哈希表能够在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间内查询到 <code>value</code> ，效率非常高。</li><li>常见的哈希表操作包括查询、添加键值对、删除键值对和遍历哈希表等。</li><li>哈希函数将 <code>key</code> 映射为数组索引，从而访问对应桶并获取 <code>value</code> 。</li><li>两个不同的 <code>key</code> 可能在经过哈希函数后得到相同的数组索引，导致查询结果出错，这种现象被称为哈希冲突。</li><li>哈希表容量越大，哈希冲突的概率就越低。因此可以通过扩容哈希表来缓解哈希冲突。与数组扩容类似，哈希表扩容操作的开销很大。</li><li>负载因子定义为哈希表中元素数量除以桶数量，反映了哈希冲突的严重程度，常用作触发哈希表扩容的条件。</li><li>链式地址通过将单个元素转化为链表，将所有冲突元素存储在同一个链表中。然而，链表过长会降低查询效率，可以通过进一步将链表转换为红黑树来提高效率。</li><li>开放寻址通过多次探测来处理哈希冲突。线性探测使用固定步长，缺点是不能删除元素，且容易产生聚集。多次哈希使用多个哈希函数进行探测，相较线性探测更不易产生聚集，但多个哈希函数增加了计算量。</li><li>不同编程语言采取了不同的哈希表实现。例如，Java 的 <code>HashMap</code> 使用链式地址，而 Python 的 <code>Dict</code> 采用开放寻址。</li><li>在哈希表中，我们希望哈希算法具有确定性、高效率和均匀分布的特点。在密码学中，哈希算法还应该具备抗碰撞性和雪崩效应。</li><li>哈希算法通常采用大质数作为模数，以最大化地保证哈希值均匀分布，减少哈希冲突。</li><li>常见的哈希算法包括 MD5、SHA-1、SHA-2 和 SHA-3 等。MD5 常用于校验文件完整性，SHA-2 常用于安全应用与协议。</li><li>编程语言通常会为数据类型提供内置哈希算法，用于计算哈希表中的桶索引。通常情况下，只有不可变对象是可哈希的。</li></ul><h3 id="Q-A">Q &amp; A</h3><p><strong>Q</strong>：哈希表的时间复杂度在什么情况下是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ？</p><p>当哈希冲突比较严重时，哈希表的时间复杂度会退化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。当哈希函数设计得比较好、容量设置比较合理、冲突比较平均时，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。我们使用编程语言内置的哈希表时，通常认为时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><p><strong>Q</strong>：为什么不使用哈希函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 呢？这样就不会有冲突了。</p><p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 哈希函数下，每个元素对应唯一的桶索引，这与数组等价。然而，输入空间通常远大于输出空间（数组长度），因此哈希函数的最后一步往往是对数组长度取模。换句话说，哈希表的目标是将一个较大的状态空间映射到一个较小的空间，并提供 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的查询效率。</p><p><strong>Q</strong>：哈希表底层实现是数组、链表、二叉树，但为什么效率可以比它们更高呢？</p><p>首先，哈希表的时间效率变高，但空间效率变低了。哈希表有相当一部分内存未使用。</p><p>其次，只是在特定使用场景下时间效率变高了。如果一个功能能够在相同的时间复杂度下使用数组或链表实现，那么通常比哈希表更快。这是因为哈希函数计算需要开销，时间复杂度的常数项更大。</p><p>最后，哈希表的时间复杂度可能发生劣化。例如在链式地址中，我们采取在链表或红黑树中执行查找操作，仍然有退化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间的风险。</p><p><strong>Q</strong>：多次哈希有不能直接删除元素的缺陷吗？标记为已删除的空间还能再次使用吗？</p><p>多次哈希是开放寻址的一种，开放寻址法都有不能直接删除元素的缺陷，需要通过标记删除。标记为已删除的空间可以再次使用。当将新元素插入哈希表，并且通过哈希函数找到标记为已删除的位置时，该位置可以被新元素使用。这样做既能保持哈希表的探测序列不变，又能保证哈希表的空间使用率。</p><p><strong>Q</strong>：为什么在线性探测中，查找元素的时候会出现哈希冲突呢？</p><p>查找的时候通过哈希函数找到对应的桶和键值对，发现 <code>key</code> 不匹配，这就代表有哈希冲突。因此，线性探测法会根据预先设定的步长依次向下查找，直至找到正确的键值对或无法找到跳出为止。</p><p><strong>Q</strong>：为什么哈希表扩容能够缓解哈希冲突？</p><p>哈希函数的最后一步往往是对数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 取模（取余），让输出值落在数组索引范围内；在扩容后，数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 发生变化，而 <code>key</code> 对应的索引也可能发生变化。原先落在同一个桶的多个 <code>key</code> ，在扩容后可能会被分配到多个桶中，从而实现哈希冲突的缓解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;小结&lt;/h1&gt;
&lt;h3 id=&quot;重点回顾&quot;&gt;重点回顾&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;输入 &lt;code&gt;key&lt;/code&gt; ，哈希表能够在 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="哈希" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/"/>
    
    
    <category term="总结" scheme="https://chaoleweisi.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>哈希算法</title>
    <link href="https://chaoleweisi.github.io/posts/22e30075/"/>
    <id>https://chaoleweisi.github.io/posts/22e30075/</id>
    <published>2024-10-13T03:48:14.000Z</published>
    <updated>2024-10-14T08:05:52.537Z</updated>
    
    <content type="html"><![CDATA[<h1>哈希算法</h1><p>前两节介绍了哈希表的工作原理和哈希冲突的处理方法。然而无论是开放寻址还是链式地址，<strong>它们只能保证哈希表可以在发生冲突时正常工作，而无法减少哈希冲突的发生</strong>。</p><p>如果哈希冲突过于频繁，哈希表的性能则会急剧劣化。如下图所示，对于链式地址哈希表，理想情况下键值对均匀分布在各个桶中，达到最佳查询效率；最差情况下所有键值对都存储到同一个桶中，时间复杂度退化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><p><img src="/posts/22e30075/hash_collision_best_worst_condition.png" alt="哈希冲突的最佳情况与最差情况"></p><p><strong>键值对的分布情况由哈希函数决定</strong>。回忆哈希函数的计算步骤，先计算哈希值，再对数组长度取模：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash(key) % capacity</span><br></pre></td></tr></table></figure><p>观察以上公式，当哈希表容量 <code>capacity</code> 固定时，<strong>哈希算法 <code>hash()</code> 决定了输出值</strong>，进而决定了键值对在哈希表中的分布情况。</p><p>这意味着，为了降低哈希冲突的发生概率，我们应当将注意力集中在哈希算法 <code>hash()</code> 的设计上。</p><h2 id="哈希算法的目标">哈希算法的目标</h2><p>为了实现“既快又稳”的哈希表数据结构，哈希算法应具备以下特点。</p><ul><li><strong>确定性</strong>：对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的。</li><li><strong>效率高</strong>：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高。</li><li><strong>均匀分布</strong>：哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率就越低。</li></ul><p>实际上，哈希算法除了可以用于实现哈希表，还广泛应用于其他领域中。</p><ul><li><strong>密码存储</strong>：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹配，那么密码就被视为正确。</li><li><strong>数据完整性检查</strong>：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整。</li></ul><p>对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全特性。</p><ul><li><strong>单向性</strong>：无法通过哈希值反推出关于输入数据的任何信息。</li><li><strong>抗碰撞性</strong>：应当极难找到两个不同的输入，使得它们的哈希值相同。</li><li><strong>雪崩效应</strong>：输入的微小变化应当导致输出的显著且不可预测的变化。</li></ul><p>请注意，<strong>“均匀分布”与“抗碰撞性”是两个独立的概念</strong>，满足均匀分布不一定满足抗碰撞性。例如，在随机输入 <code>key</code> 下，哈希函数 <code>key % 100</code> 可以产生均匀分布的输出。然而该哈希算法过于简单，所有后两位相等的 <code>key</code> 的输出都相同，因此我们可以很容易地从哈希值反推出可用的 <code>key</code> ，从而破解密码。</p><h2 id="哈希算法的设计">哈希算法的设计</h2><p>哈希算法的设计是一个需要考虑许多因素的复杂问题。然而对于某些要求不高的场景，我们也能设计一些简单的哈希算法。</p><ul><li><strong>加法哈希</strong>：对输入的每个字符的 ASCII 码进行相加，将得到的总和作为哈希值。</li><li><strong>乘法哈希</strong>：利用乘法的不相关性，每轮乘以一个常数，将各个字符的 ASCII 码累积到哈希值中。</li><li><strong>异或哈希</strong>：将输入数据的每个元素通过异或操作累积到一个哈希值中。</li><li><strong>旋转哈希</strong>：将每个字符的 ASCII 码累积到一个哈希值中，每次累积之前都会对哈希值进行旋转操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;加法哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> += <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;乘法哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> = <span class="number">31</span> * <span class="built_in">hash</span> + <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;异或哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> ^= <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rot_hash</span>(<span class="params">key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;旋转哈希&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">hash</span> = <span class="number">0</span></span><br><span class="line">    modulus = <span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        <span class="built_in">hash</span> = (<span class="built_in">hash</span> &lt;&lt; <span class="number">4</span>) ^ (<span class="built_in">hash</span> &gt;&gt; <span class="number">28</span>) ^ <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span> % modulus</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    key = <span class="string">&quot;Hello 算法&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">hash</span> = add_hash(key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;加法哈希值为 <span class="subst">&#123;<span class="built_in">hash</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hash</span> = mul_hash(key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;乘法哈希值为 <span class="subst">&#123;<span class="built_in">hash</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hash</span> = xor_hash(key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;异或哈希值为 <span class="subst">&#123;<span class="built_in">hash</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hash</span> = rot_hash(key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;旋转哈希值为 <span class="subst">&#123;<span class="built_in">hash</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>观察发现，每种哈希算法的最后一步都是对大质数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000000007</mn></mrow><annotation encoding="application/x-tex">1000000007</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000000007</span></span></span></span> 取模，以确保哈希值在合适的范围内。值得思考的是，为什么要强调对质数取模，或者说对合数取模的弊端是什么？这是一个有趣的问题。</p><p>先抛出结论：<strong>使用大质数作为模数，可以最大化地保证哈希值的均匀分布</strong>。因为质数不与其他数字存在公约数，可以减少因取模操作而产生的周期性模式，从而避免哈希冲突。</p><p>举个例子，假设我们选择合数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 作为模数，它可以被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 整除，那么所有可以被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 整除的 <code>key</code> 都会被映射到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 这三个哈希值。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>modulus</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>9</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>key</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>18</mn><mo separator="true">,</mo><mn>21</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>27</mn><mo separator="true">,</mo><mn>30</mn><mo separator="true">,</mo><mn>33</mn><mo separator="true">,</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>hash</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\text{modulus} &amp; = 9 \newline\text{key} &amp; = \{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \dots \} \newline\text{hash} &amp; = \{ 0, 3, 6, 0, 3, 6, 0, 3, 6, 0, 3, 6,\dots \}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.5em;vertical-align:-2em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">modulus</span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">key</span></span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">hash</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">9</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">18</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">21</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">24</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">27</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">33</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">}</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">}</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>如果输入 <code>key</code> 恰好满足这种等差数列的数据分布，那么哈希值就会出现聚堆，从而加重哈希冲突。现在，假设将 <code>modulus</code> 替换为质数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>13</mn></mrow><annotation encoding="application/x-tex">13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">13</span></span></span></span> ，由于 <code>key</code> 和 <code>modulus</code> 之间不存在公约数，因此输出的哈希值的均匀性会明显提升。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>modulus</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>13</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>key</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>18</mn><mo separator="true">,</mo><mn>21</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>27</mn><mo separator="true">,</mo><mn>30</mn><mo separator="true">,</mo><mn>33</mn><mo separator="true">,</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>hash</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\text{modulus} &amp; = 13 \newline\text{key} &amp; = \{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \dots \} \newline\text{hash} &amp; = \{ 0, 3, 6, 9, 12, 2, 5, 8, 11, 1, 4, 7, \dots \}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.5em;vertical-align:-2em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">modulus</span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">key</span></span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">hash</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">13</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">18</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">21</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">24</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">27</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">33</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">}</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">11</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">}</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>值得说明的是，如果能够保证 <code>key</code> 是随机均匀分布的，那么选择质数或者合数作为模数都可以，它们都能输出均匀分布的哈希值。而当 <code>key</code> 的分布存在某种周期性时，对合数取模更容易出现聚集现象。</p><p>总而言之，我们通常选取质数作为模数，并且这个质数最好足够大，以尽可能消除周期性模式，提升哈希算法的稳健性。</p><h2 id="常见哈希算法">常见哈希算法</h2><p>不难发现，以上介绍的简单哈希算法都比较“脆弱”，远远没有达到哈希算法的设计目标。例如，由于加法和异或满足交换律，因此加法哈希和异或哈希无法区分内容相同但顺序不同的字符串，这可能会加剧哈希冲突，并引起一些安全问题。</p><p>在实际中，我们通常会用一些标准哈希算法，例如 MD5、SHA-1、SHA-2 和 SHA-3 等。它们可以将任意长度的输入数据映射到恒定长度的哈希值。</p><p>近一个世纪以来，哈希算法处在不断升级与优化的过程中。一部分研究人员努力提升哈希算法的性能，另一部分研究人员和黑客则致力于寻找哈希算法的安全性问题。下表展示了在实际应用中常见的哈希算法。</p><ul><li>MD5 和 SHA-1 已多次被成功攻击，因此它们被各类安全应用弃用。</li><li>SHA-2 系列中的 SHA-256 是最安全的哈希算法之一，仍未出现成功的攻击案例，因此常用在各类安全应用与协议中。</li><li>SHA-3 相较 SHA-2 的实现开销更低、计算效率更高，但目前使用覆盖度不如 SHA-2 系列。</li></ul><p align="center"> 表 <id> &nbsp; 常见的哈希算法 </id></p><table><thead><tr><th></th><th>MD5</th><th>SHA-1</th><th>SHA-2</th><th>SHA-3</th></tr></thead><tbody><tr><td>推出时间</td><td>1992</td><td>1995</td><td>2002</td><td>2008</td></tr><tr><td>输出长度</td><td>128 bit</td><td>160 bit</td><td>256/512 bit</td><td>224/256/384/512 bit</td></tr><tr><td>哈希冲突</td><td>较多</td><td>较多</td><td>很少</td><td>很少</td></tr><tr><td>安全等级</td><td>低，已被成功攻击</td><td>低，已被成功攻击</td><td>高</td><td>高</td></tr><tr><td>应用</td><td>已被弃用，仍用于数据完整性检查</td><td>已被弃用</td><td>加密货币交易验证、数字签名等</td><td>可用于替代 SHA-2</td></tr></tbody></table><h2 id="数据结构的哈希值">数据结构的哈希值</h2><p>我们知道，哈希表的 <code>key</code> 可以是整数、小数或字符串等数据类型。编程语言通常会为这些数据类型提供内置的哈希算法，用于计算哈希表中的桶索引。以 Python 为例，我们可以调用 <code>hash()</code> 函数来计算各种数据类型的哈希值。</p><ul><li>整数和布尔量的哈希值就是其本身。</li><li>浮点数和字符串的哈希值计算较为复杂，有兴趣的读者请自行学习。</li><li>元组的哈希值是对其中每一个元素进行哈希，然后将这些哈希值组合起来，得到单一的哈希值。</li><li>对象的哈希值基于其内存地址生成。通过重写对象的哈希方法，可实现基于内容生成哈希值。</li></ul><p>!!! tip</p><pre><code>请注意，不同编程语言的内置哈希值计算函数的定义和方法不同。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">3</span></span><br><span class="line">hash_num = <span class="built_in">hash</span>(num)</span><br><span class="line"><span class="comment"># 整数 3 的哈希值为 3</span></span><br><span class="line"></span><br><span class="line">bol = <span class="literal">True</span></span><br><span class="line">hash_bol = <span class="built_in">hash</span>(bol)</span><br><span class="line"><span class="comment"># 布尔量 True 的哈希值为 1</span></span><br><span class="line"></span><br><span class="line">dec = <span class="number">3.14159</span></span><br><span class="line">hash_dec = <span class="built_in">hash</span>(dec)</span><br><span class="line"><span class="comment"># 小数 3.14159 的哈希值为 326484311674566659</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hello 算法&quot;</span></span><br><span class="line">hash_str = <span class="built_in">hash</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 字符串“Hello 算法”的哈希值为 4617003410720528961</span></span><br><span class="line"></span><br><span class="line">tup = (<span class="number">12836</span>, <span class="string">&quot;小哈&quot;</span>)</span><br><span class="line">hash_tup = <span class="built_in">hash</span>(tup)</span><br><span class="line"><span class="comment"># 元组 (12836, &#x27;小哈&#x27;) 的哈希值为 1029005403108185979</span></span><br><span class="line"></span><br><span class="line">obj = ListNode(<span class="number">0</span>)</span><br><span class="line">hash_obj = <span class="built_in">hash</span>(obj)</span><br><span class="line"><span class="comment"># 节点对象 &lt;ListNode object at 0x1058fd810&gt; 的哈希值为 274267521</span></span><br></pre></td></tr></table></figure><p>在许多编程语言中，<strong>只有不可变对象才可作为哈希表的 <code>key</code></strong> 。假如我们将列表（动态数组）作为 <code>key</code> ，当列表的内容发生变化时，它的哈希值也随之改变，我们就无法在哈希表中查询到原先的 <code>value</code> 了。</p><p>虽然自定义对象（比如链表节点）的成员变量是可变的，但它是可哈希的。<strong>这是因为对象的哈希值通常是基于内存地址生成的</strong>，即使对象的内容发生了变化，但它的内存地址不变，哈希值仍然是不变的。</p><p>细心的你可能发现在不同控制台中运行程序时，输出的哈希值是不同的。<strong>这是因为 Python 解释器在每次启动时，都会为字符串哈希函数加入一个随机的盐（salt）值</strong>。这种做法可以有效防止 HashDoS 攻击，提升哈希算法的安全性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;哈希算法&lt;/h1&gt;
&lt;p&gt;前两节介绍了哈希表的工作原理和哈希冲突的处理方法。然而无论是开放寻址还是链式地址，&lt;strong&gt;它们只能保证哈希表可以在发生冲突时正常工作，而无法减少哈希冲突的发生&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果哈希冲突过于频繁，哈希表的性能则会急剧劣</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="哈希" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/"/>
    
    
    <category term="哈希算法" scheme="https://chaoleweisi.github.io/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希冲突</title>
    <link href="https://chaoleweisi.github.io/posts/896e8de5/"/>
    <id>https://chaoleweisi.github.io/posts/896e8de5/</id>
    <published>2024-10-13T03:42:14.000Z</published>
    <updated>2024-10-14T08:06:33.408Z</updated>
    
    <content type="html"><![CDATA[<h1>哈希冲突</h1><p>上一节提到，<strong>通常情况下哈希函数的输入空间远大于输出空间</strong>，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。</p><p>哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。</p><ol><li>改良哈希表数据结构，<strong>使得哈希表可以在出现哈希冲突时正常工作</strong>。</li><li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li></ol><p>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。</p><h2 id="链式地址">链式地址</h2><p>在原始哈希表中，每个桶仅能存储一个键值对。<u>链式地址（separate chaining）</u>将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。下图展示了一个链式地址哈希表的例子。</p><p><img src="/posts/896e8de5/hash_table_chaining.png" alt="链式地址哈希表"></p><p>基于链式地址实现的哈希表的操作方法发生了以下变化。</p><ul><li><strong>查询元素</strong>：输入 <code>key</code> ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 <code>key</code> 以查找目标键值对。</li><li><strong>添加元素</strong>：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。</li><li><strong>删除元素</strong>：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。</li></ul><p>链式地址存在以下局限性。</p><ul><li><strong>占用空间增大</strong>：链表包含节点指针，它相比数组更加耗费内存空间。</li><li><strong>查询效率降低</strong>：因为需要线性遍历链表来查找对应元素。</li></ul><p>以下代码给出了链式地址哈希表的简单实现，需要注意两点。</p><ul><li>使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表。</li><li>以下实现包含哈希表扩容方法。当负载因子超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>2</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{2}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 时，我们将哈希表扩容至原先的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 倍。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;链式地址哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span>  <span class="comment"># 键值对数量</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity = <span class="number">4</span>  <span class="comment"># 哈希表容量</span></span><br><span class="line">        <span class="variable language_">self</span>.load_thres = <span class="number">2.0</span> / <span class="number">3.0</span>  <span class="comment"># 触发扩容的负载因子阈值</span></span><br><span class="line">        <span class="variable language_">self</span>.extend_ratio = <span class="number">2</span>  <span class="comment"># 扩容倍数</span></span><br><span class="line">        <span class="variable language_">self</span>.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.capacity)]  <span class="comment"># 桶数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;哈希函数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> key % <span class="variable language_">self</span>.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_factor</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;负载因子&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size / <span class="variable language_">self</span>.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span> | <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查询操作&quot;&quot;&quot;</span></span><br><span class="line">        index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">        bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">        <span class="comment"># 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">            <span class="keyword">if</span> pair.key == key:</span><br><span class="line">                <span class="keyword">return</span> pair.val</span><br><span class="line">        <span class="comment"># 若未找到 key ，则返回 None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.load_factor() &gt; <span class="variable language_">self</span>.load_thres:</span><br><span class="line">            <span class="variable language_">self</span>.extend()</span><br><span class="line">        index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">        bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">        <span class="comment"># 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">            <span class="keyword">if</span> pair.key == key:</span><br><span class="line">                pair.val = val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        pair = Pair(key, val)</span><br><span class="line">        bucket.append(pair)</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除操作&quot;&quot;&quot;</span></span><br><span class="line">        index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">        bucket = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">        <span class="comment"># 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">            <span class="keyword">if</span> pair.key == key:</span><br><span class="line">                bucket.remove(pair)</span><br><span class="line">                <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;扩容哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 暂存原哈希表</span></span><br><span class="line">        buckets = <span class="variable language_">self</span>.buckets</span><br><span class="line">        <span class="comment"># 初始化扩容后的新哈希表</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity *= <span class="variable language_">self</span>.extend_ratio</span><br><span class="line">        <span class="variable language_">self</span>.buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.capacity)]</span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">                <span class="variable language_">self</span>.put(pair.key, pair.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> pair <span class="keyword">in</span> bucket:</span><br><span class="line">                res.append(<span class="built_in">str</span>(pair.key) + <span class="string">&quot; -&gt; &quot;</span> + pair.val)</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化哈希表</span></span><br><span class="line">    hashmap = HashMapChaining()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加操作</span></span><br><span class="line">    <span class="comment"># 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">    hashmap.put(<span class="number">12836</span>, <span class="string">&quot;小哈&quot;</span>)</span><br><span class="line">    hashmap.put(<span class="number">15937</span>, <span class="string">&quot;小啰&quot;</span>)</span><br><span class="line">    hashmap.put(<span class="number">16750</span>, <span class="string">&quot;小算&quot;</span>)</span><br><span class="line">    hashmap.put(<span class="number">13276</span>, <span class="string">&quot;小法&quot;</span>)</span><br><span class="line">    hashmap.put(<span class="number">10583</span>, <span class="string">&quot;小鸭&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n添加完成后，哈希表为\n[Key1 -&gt; Value1, Key2 -&gt; Value2, ...]&quot;</span>)</span><br><span class="line">    hashmap.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询操作</span></span><br><span class="line">    <span class="comment"># 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line">    name = hashmap.get(<span class="number">13276</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n输入学号 13276 ，查询到姓名 &quot;</span> + name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除操作</span></span><br><span class="line">    <span class="comment"># 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">    hashmap.remove(<span class="number">12836</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n删除 12836 后，哈希表为\n[Key1 -&gt; Value1, Key2 -&gt; Value2, ...]&quot;</span>)</span><br><span class="line">    hashmap.<span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>值得注意的是，当链表很长时，查询效率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 很差。<strong>此时可以将链表转换为“AVL 树”或“红黑树”</strong>，从而将查询操作的时间复杂度优化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><h2 id="开放寻址">开放寻址</h2><p><u>开放寻址（open addressing）</u>不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。</p><p>下面以线性探测为例，介绍开放寻址哈希表的工作机制。</p><h3 id="线性探测">线性探测</h3><p>线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。</p><ul><li><strong>插入元素</strong>：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ），直至找到空桶，将元素插入其中。</li><li><strong>查找元素</strong>：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 <code>None</code> 。</li></ul><p>下图展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 <code>key</code> 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中。</p><p><img src="/posts/896e8de5/hash_table_linear_probing.png" alt="开放寻址（线性探测）哈希表的键值对分布"></p><p>然而，<strong>线性探测容易产生“聚集现象”</strong>。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</p><p>值得注意的是，<strong>我们不能在开放寻址哈希表中直接删除元素</strong>。这是因为删除元素会在数组内产生一个空桶 <code>None</code> ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在，如下图所示。</p><p><img src="/posts/896e8de5/hash_table_open_addressing_deletion.png" alt="在开放寻址中删除元素导致的查询问题"></p><p>为了解决该问题，我们可以采用<u>懒删除（lazy deletion）</u>机制：它不直接从哈希表中移除元素，<strong>而是利用一个常量 <code>TOMBSTONE</code> 来标记这个桶</strong>。在该机制下，<code>None</code> 和 <code>TOMBSTONE</code> 都代表空桶，都可以放置键值对。但不同的是，线性探测到 <code>TOMBSTONE</code> 时应该继续遍历，因为其之下可能还存在键值对。</p><p>然而，<strong>懒删除可能会加速哈希表的性能退化</strong>。这是因为每次删除操作都会产生一个删除标记，随着 <code>TOMBSTONE</code> 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 <code>TOMBSTONE</code> 才能找到目标元素。</p><p>为此，考虑在线性探测中记录遇到的首个 <code>TOMBSTONE</code> 的索引，并将搜索到的目标元素与该 <code>TOMBSTONE</code> 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。</p><p>以下代码实现了一个包含懒删除的开放寻址（线性探测）哈希表。为了更加充分地使用哈希表的空间，我们将哈希表看作一个“环形数组”，当越过数组尾部时，回到头部继续遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;开放寻址哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span>  <span class="comment"># 键值对数量</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity = <span class="number">4</span>  <span class="comment"># 哈希表容量</span></span><br><span class="line">        <span class="variable language_">self</span>.load_thres = <span class="number">2.0</span> / <span class="number">3.0</span>  <span class="comment"># 触发扩容的负载因子阈值</span></span><br><span class="line">        <span class="variable language_">self</span>.extend_ratio = <span class="number">2</span>  <span class="comment"># 扩容倍数</span></span><br><span class="line">        <span class="variable language_">self</span>.buckets: <span class="built_in">list</span>[Pair | <span class="literal">None</span>] = [<span class="literal">None</span>] * <span class="variable language_">self</span>.capacity  <span class="comment"># 桶数组</span></span><br><span class="line">        <span class="variable language_">self</span>.TOMBSTONE = Pair(-<span class="number">1</span>, <span class="string">&quot;-1&quot;</span>)  <span class="comment"># 删除标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;哈希函数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> key % <span class="variable language_">self</span>.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_factor</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;负载因子&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size / <span class="variable language_">self</span>.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_bucket</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;搜索 key 对应的桶索引&quot;&quot;&quot;</span></span><br><span class="line">        index = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">        first_tombstone = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index].key == key:</span><br><span class="line">                <span class="comment"># 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> first_tombstone != -<span class="number">1</span>:</span><br><span class="line">                    <span class="variable language_">self</span>.buckets[first_tombstone] = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">                    <span class="variable language_">self</span>.buckets[index] = <span class="variable language_">self</span>.TOMBSTONE</span><br><span class="line">                    <span class="keyword">return</span> first_tombstone  <span class="comment"># 返回移动后的桶索引</span></span><br><span class="line">                <span class="keyword">return</span> index  <span class="comment"># 返回桶索引</span></span><br><span class="line">            <span class="comment"># 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> first_tombstone == -<span class="number">1</span> <span class="keyword">and</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">is</span> <span class="variable language_">self</span>.TOMBSTONE:</span><br><span class="line">                first_tombstone = index</span><br><span class="line">            <span class="comment"># 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % <span class="variable language_">self</span>.capacity</span><br><span class="line">        <span class="comment"># 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">        <span class="keyword">return</span> index <span class="keyword">if</span> first_tombstone == -<span class="number">1</span> <span class="keyword">else</span> first_tombstone</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查询操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">        index = <span class="variable language_">self</span>.find_bucket(key)</span><br><span class="line">        <span class="comment"># 若找到键值对，则返回对应 val</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.buckets[index].val</span><br><span class="line">        <span class="comment"># 若键值对不存在，则返回 None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.load_factor() &gt; <span class="variable language_">self</span>.load_thres:</span><br><span class="line">            <span class="variable language_">self</span>.extend()</span><br><span class="line">        <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">        index = <span class="variable language_">self</span>.find_bucket(key)</span><br><span class="line">        <span class="comment"># 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">            <span class="variable language_">self</span>.buckets[index].val = val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 若键值对不存在，则添加该键值对</span></span><br><span class="line">        <span class="variable language_">self</span>.buckets[index] = Pair(key, val)</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 搜索 key 对应的桶索引</span></span><br><span class="line">        index = <span class="variable language_">self</span>.find_bucket(key)</span><br><span class="line">        <span class="comment"># 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.buckets[index] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">            <span class="variable language_">self</span>.buckets[index] = <span class="variable language_">self</span>.TOMBSTONE</span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;扩容哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 暂存原哈希表</span></span><br><span class="line">        buckets_tmp = <span class="variable language_">self</span>.buckets</span><br><span class="line">        <span class="comment"># 初始化扩容后的新哈希表</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity *= <span class="variable language_">self</span>.extend_ratio</span><br><span class="line">        <span class="variable language_">self</span>.buckets = [<span class="literal">None</span>] * <span class="variable language_">self</span>.capacity</span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> buckets_tmp:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">not</span> <span class="keyword">in</span> [<span class="literal">None</span>, <span class="variable language_">self</span>.TOMBSTONE]:</span><br><span class="line">                <span class="variable language_">self</span>.put(pair.key, pair.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> pair <span class="keyword">is</span> <span class="variable language_">self</span>.TOMBSTONE:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;TOMBSTONE&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(pair.key, <span class="string">&quot;-&gt;&quot;</span>, pair.val)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化哈希表</span></span><br><span class="line">    hashmap = HashMapOpenAddressing()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加操作</span></span><br><span class="line">    <span class="comment"># 在哈希表中添加键值对 (key, val)</span></span><br><span class="line">    hashmap.put(<span class="number">12836</span>, <span class="string">&quot;小哈&quot;</span>)</span><br><span class="line">    hashmap.put(<span class="number">15937</span>, <span class="string">&quot;小啰&quot;</span>)</span><br><span class="line">    hashmap.put(<span class="number">16750</span>, <span class="string">&quot;小算&quot;</span>)</span><br><span class="line">    hashmap.put(<span class="number">13276</span>, <span class="string">&quot;小法&quot;</span>)</span><br><span class="line">    hashmap.put(<span class="number">10583</span>, <span class="string">&quot;小鸭&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n添加完成后，哈希表为\nKey -&gt; Value&quot;</span>)</span><br><span class="line">    hashmap.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询操作</span></span><br><span class="line">    <span class="comment"># 向哈希表中输入键 key ，得到值 val</span></span><br><span class="line">    name = hashmap.get(<span class="number">13276</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n输入学号 13276 ，查询到姓名 &quot;</span> + name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除操作</span></span><br><span class="line">    <span class="comment"># 在哈希表中删除键值对 (key, val)</span></span><br><span class="line">    hashmap.remove(<span class="number">16750</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n删除 16750 后，哈希表为\nKey -&gt; Value&quot;</span>)</span><br><span class="line">    hashmap.<span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h3 id="平方探测">平方探测</h3><p>平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">1, 4, 9, \dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span></span></span></span> 步。</p><p>平方探测主要具有以下优势。</p><ul><li>平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。</li><li>平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。</li></ul><p>然而，平方探测并不是完美的。</p><ul><li>仍然存在聚集现象，即某些位置比其他位置更容易被占用。</li><li>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。</li></ul><h3 id="多次哈希">多次哈希</h3><p>顾名思义，多次哈希方法使用多个哈希函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_1(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>3</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_3(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.123em;"></span><span class="minner">…</span></span></span></span> 进行探测。</p><ul><li><strong>插入元素</strong>：若哈希函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_1(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 出现冲突，则尝试 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> ，以此类推，直到找到空位后插入元素。</li><li><strong>查找元素</strong>：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 <code>None</code> 。</li></ul><p>与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。</p><pre><code>请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。</code></pre><h2 id="编程语言的选择">编程语言的选择</h2><p>各种编程语言采取了不同的哈希表实现策略，下面举几个例子。</p><ul><li>Python 采用开放寻址。字典 <code>dict</code> 使用伪随机数进行探测。</li><li>Java 采用链式地址。自 JDK 1.8 以来，当 <code>HashMap</code> 内数组长度达到 64 且链表长度达到 8 时，链表会转换为红黑树以提升查找性能。</li><li>Go 采用链式地址。Go 规定每个桶最多存储 8 个键值对，超出容量则连接一个溢出桶；当溢出桶过多时，会执行一次特殊的等量扩容操作，以确保性能。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;哈希冲突&lt;/h1&gt;
&lt;p&gt;上一节提到，&lt;strong&gt;通常情况下哈希函数的输入空间远大于输出空间&lt;/strong&gt;，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。&lt;/p&gt;
&lt;p&gt;哈希冲突会导致查询结果错</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="哈希" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/"/>
    
    
    <category term="哈希冲突" scheme="https://chaoleweisi.github.io/tags/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://chaoleweisi.github.io/posts/850f2080/"/>
    <id>https://chaoleweisi.github.io/posts/850f2080/</id>
    <published>2024-10-13T03:29:14.000Z</published>
    <updated>2024-10-14T06:27:22.902Z</updated>
    
    <content type="html"><![CDATA[<h1>哈希表</h1><p><u>哈希表（hash table）</u>，又称<u>散列表</u>，它通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 <code>key</code> ，则可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间内获取对应的值 <code>value</code> 。</p><p>如下图所示，给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个学生，每个学生都有“姓名”和“学号”两项数据。假如我们希望实现“输入一个学号，返回对应的姓名”的查询功能，则可以采用下图所示的哈希表来实现。</p><p><img src="/posts/850f2080/hash_table_lookup.png" alt="哈希表的抽象表示"></p><p>除哈希表外，数组和链表也可以实现查询功能，它们的效率对比如下表所示。</p><ul><li><strong>添加元素</strong>：仅需将元素添加至数组（链表）的尾部即可，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间。</li><li><strong>查询元素</strong>：由于数组（链表）是乱序的，因此需要遍历其中的所有元素，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间。</li><li><strong>删除元素</strong>：需要先查询到元素，再从数组（链表）中删除，使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 时间。</li></ul><p align="center"> 表 <id> &nbsp; 元素查询效率对比 </id></p><table><thead><tr><th></th><th>数组</th><th>链表</th><th>哈希表</th></tr></thead><tbody><tr><td>查找元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>添加元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td>删除元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><p>观察发现，<strong>在哈希表中进行增删查改的时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></strong> ，非常高效。</p><h2 id="哈希表常用操作">哈希表常用操作</h2><p>哈希表的常见操作包括：初始化、查询操作、添加键值对和删除键值对等，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化哈希表</span></span><br><span class="line">hmap: <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加操作</span></span><br><span class="line"><span class="comment"># 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">hmap[<span class="number">12836</span>] = <span class="string">&quot;小哈&quot;</span></span><br><span class="line">hmap[<span class="number">15937</span>] = <span class="string">&quot;小啰&quot;</span></span><br><span class="line">hmap[<span class="number">16750</span>] = <span class="string">&quot;小算&quot;</span></span><br><span class="line">hmap[<span class="number">13276</span>] = <span class="string">&quot;小法&quot;</span></span><br><span class="line">hmap[<span class="number">10583</span>] = <span class="string">&quot;小鸭&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询操作</span></span><br><span class="line"><span class="comment"># 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line">name: <span class="built_in">str</span> = hmap[<span class="number">15937</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除操作</span></span><br><span class="line"><span class="comment"># 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">hmap.pop(<span class="number">10583</span>)</span><br></pre></td></tr></table></figure><p>哈希表有三种常用的遍历方式：遍历键值对、遍历键和遍历值。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历哈希表</span></span><br><span class="line"><span class="comment"># 遍历键值对 key-&gt;value</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> hmap.items():</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&quot;-&gt;&quot;</span>, value)</span><br><span class="line"><span class="comment"># 单独遍历键 key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> hmap.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"><span class="comment"># 单独遍历值 value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> hmap.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><h2 id="哈希表简单实现">哈希表简单实现</h2><p>我们先考虑最简单的情况，<strong>仅用一个数组来实现哈希表</strong>。在哈希表中，我们将数组中的每个空位称为<u>桶（bucket）</u>，每个桶可存储一个键值对。因此，查询操作就是找到 <code>key</code> 对应的桶，并在桶中获取 <code>value</code> 。</p><p>那么，如何基于 <code>key</code> 定位对应的桶呢？这是通过<u>哈希函数（hash function）</u>实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 <code>key</code> ，输出空间是所有桶（数组索引）。换句话说，输入一个 <code>key</code> ，<strong>我们可以通过哈希函数得到该 <code>key</code> 对应的键值对在数组中的存储位置</strong>。</p><p>输入一个 <code>key</code> ，哈希函数的计算过程分为以下两步。</p><ol><li>通过某种哈希算法 <code>hash()</code> 计算得到哈希值。</li><li>将哈希值对桶数量（数组长度）<code>capacity</code> 取模，从而获取该 <code>key</code> 对应的数组索引 <code>index</code> 。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash(key) % capacity</span><br></pre></td></tr></table></figure><p>随后，我们就可以利用 <code>index</code> 在哈希表中访问对应的桶，从而获取 <code>value</code> 。</p><p>设数组长度 <code>capacity = 100</code>、哈希算法 <code>hash(key) = key</code> ，易得哈希函数为 <code>key % 100</code> 。下图以 <code>key</code> 学号和 <code>value</code> 姓名为例，展示了哈希函数的工作原理。</p><p><img src="/posts/850f2080/hash_function.png" alt="哈希函数工作原理"></p><p>以下代码实现了一个简单哈希表。其中，我们将 <code>key</code> 和 <code>value</code> 封装成一个类 <code>Pair</code> ，以表示键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;键值对&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.key = key</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayHashMap</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于数组实现的哈希表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化数组，包含 100 个桶</span></span><br><span class="line">        <span class="variable language_">self</span>.buckets: <span class="built_in">list</span>[Pair | <span class="literal">None</span>] = [<span class="literal">None</span>] * <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;哈希函数&quot;&quot;&quot;</span></span><br><span class="line">        index = key % <span class="number">100</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查询操作&quot;&quot;&quot;</span></span><br><span class="line">        index: <span class="built_in">int</span> = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">        pair: Pair = <span class="variable language_">self</span>.buckets[index]</span><br><span class="line">        <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> pair.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, val: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加操作&quot;&quot;&quot;</span></span><br><span class="line">        pair = Pair(key, val)</span><br><span class="line">        index: <span class="built_in">int</span> = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">        <span class="variable language_">self</span>.buckets[index] = pair</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除操作&quot;&quot;&quot;</span></span><br><span class="line">        index: <span class="built_in">int</span> = <span class="variable language_">self</span>.hash_func(key)</span><br><span class="line">        <span class="comment"># 置为 None ，代表删除</span></span><br><span class="line">        <span class="variable language_">self</span>.buckets[index] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">entry_set</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[Pair]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取所有键值对&quot;&quot;&quot;</span></span><br><span class="line">        result: <span class="built_in">list</span>[Pair] = []</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                result.append(pair)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">key_set</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取所有键&quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                result.append(pair.key)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">value_set</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取所有值&quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                result.append(pair.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印哈希表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="variable language_">self</span>.buckets:</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(pair.key, <span class="string">&quot;-&gt;&quot;</span>, pair.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化哈希表</span></span><br><span class="line">    hmap = ArrayHashMap()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加操作</span></span><br><span class="line">    <span class="comment"># 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">    hmap.put(<span class="number">12836</span>, <span class="string">&quot;小哈&quot;</span>)</span><br><span class="line">    hmap.put(<span class="number">15937</span>, <span class="string">&quot;小啰&quot;</span>)</span><br><span class="line">    hmap.put(<span class="number">16750</span>, <span class="string">&quot;小算&quot;</span>)</span><br><span class="line">    hmap.put(<span class="number">13276</span>, <span class="string">&quot;小法&quot;</span>)</span><br><span class="line">    hmap.put(<span class="number">10583</span>, <span class="string">&quot;小鸭&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n添加完成后，哈希表为\nKey -&gt; Value&quot;</span>)</span><br><span class="line">    hmap.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询操作</span></span><br><span class="line">    <span class="comment"># 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line">    name = hmap.get(<span class="number">15937</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n输入学号 15937 ，查询到姓名 &quot;</span> + name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除操作</span></span><br><span class="line">    <span class="comment"># 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">    hmap.remove(<span class="number">10583</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n删除 10583 后，哈希表为\nKey -&gt; Value&quot;</span>)</span><br><span class="line">    hmap.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历哈希表</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n遍历键值对 Key-&gt;Value&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> pair <span class="keyword">in</span> hmap.entry_set():</span><br><span class="line">        <span class="built_in">print</span>(pair.key, <span class="string">&quot;-&gt;&quot;</span>, pair.val)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n单独遍历键 Key&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> hmap.key_set():</span><br><span class="line">        <span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n单独遍历值 Value&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> hmap.value_set():</span><br><span class="line">        <span class="built_in">print</span>(val)</span><br></pre></td></tr></table></figure><h2 id="哈希冲突与扩容">哈希冲突与扩容</h2><p>从本质上看，哈希函数的作用是将所有 <code>key</code> 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，<strong>理论上一定存在“多个输入对应相同输出”的情况</strong>。</p><p>对于上述示例中的哈希函数，当输入的 <code>key</code> 后两位相同时，哈希函数的输出结果也相同。例如，查询学号为 12836 和 20336 的两个学生时，我们得到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12836 % 100 = 36</span><br><span class="line">20336 % 100 = 36</span><br></pre></td></tr></table></figure><p>如下图所示，两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为<u>哈希冲突（hash collision）</u>。</p><p><img src="/posts/850f2080/hash_collision.png" alt="哈希冲突示例"></p><p>容易想到，哈希表容量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 越大，多个 <code>key</code> 被分配到同一个桶中的概率就越低，冲突就越少。因此，<strong>我们可以通过扩容哈希表来减少哈希冲突</strong>。</p><p>如下图所示，扩容前键值对 <code>(136, A)</code> 和 <code>(236, D)</code> 发生冲突，扩容后冲突消失。</p><p><img src="/posts/850f2080/hash_table_reshash.png" alt="哈希表扩容"></p><p>类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 <code>capacity</code> 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。</p><p><u>负载因子（load factor）</u>是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，<strong>也常作为哈希表扩容的触发条件</strong>。例如在 Java 中，当负载因子超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.75</mn></mrow><annotation encoding="application/x-tex">0.75</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.75</span></span></span></span> 时，系统会将哈希表扩容至原先的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 倍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;哈希表&lt;/h1&gt;
&lt;p&gt;&lt;u&gt;哈希表（hash table）&lt;/u&gt;，又称&lt;u&gt;散列表&lt;/u&gt;，它通过建立键 &lt;code&gt;key&lt;/code&gt; 与值 &lt;code&gt;value&lt;/code&gt; 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 &lt;code&gt;ke</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="哈希" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C/"/>
    
    
    <category term="哈希表" scheme="https://chaoleweisi.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>双向队列</title>
    <link href="https://chaoleweisi.github.io/posts/a25b461a/"/>
    <id>https://chaoleweisi.github.io/posts/a25b461a/</id>
    <published>2024-10-13T03:20:14.000Z</published>
    <updated>2024-10-14T07:45:56.527Z</updated>
    
    <content type="html"><![CDATA[<h1>双向队列</h1><p>在队列中，我们仅能删除头部元素或在尾部添加元素。如下图所示，<u>双向队列（double-ended queue）</u>提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作。</p><p><img src="/posts/a25b461a/deque_operations.png" alt="双向队列的操作"></p><h2 id="双向队列常用操作">双向队列常用操作</h2><p>双向队列的常用操作如下表所示，具体的方法名称需要根据所使用的编程语言来确定。</p><p align="center"> 表 <id> &nbsp; 双向队列操作效率 </id></p><table><thead><tr><th>方法名</th><th>描述</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>push_first()</code></td><td>将元素添加至队首</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>push_last()</code></td><td>将元素添加至队尾</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>pop_first()</code></td><td>删除队首元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>pop_last()</code></td><td>删除队尾元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>peek_first()</code></td><td>访问队首元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr><tr><td><code>peek_last()</code></td><td>访问队尾元素</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><p>同样地，我们可以直接使用编程语言中已实现的双向队列类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化双向队列</span></span><br><span class="line">deq: deque[<span class="built_in">int</span>] = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入队</span></span><br><span class="line">deq.append(<span class="number">2</span>)      <span class="comment"># 添加至队尾</span></span><br><span class="line">deq.append(<span class="number">5</span>)</span><br><span class="line">deq.append(<span class="number">4</span>)</span><br><span class="line">deq.appendleft(<span class="number">3</span>)  <span class="comment"># 添加至队首</span></span><br><span class="line">deq.appendleft(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line">front: <span class="built_in">int</span> = deq[<span class="number">0</span>]  <span class="comment"># 队首元素</span></span><br><span class="line">rear: <span class="built_in">int</span> = deq[-<span class="number">1</span>]  <span class="comment"># 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出队</span></span><br><span class="line">pop_front: <span class="built_in">int</span> = deq.popleft()  <span class="comment"># 队首元素出队</span></span><br><span class="line">pop_rear: <span class="built_in">int</span> = deq.pop()       <span class="comment"># 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取双向队列的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(deq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断双向队列是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(deq) == <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="双向队列实现">双向队列实现 *</h2><p>双向队列的实现与队列类似，可以选择链表或数组作为底层数据结构。</p><h3 id="基于双向链表的实现">基于双向链表的实现</h3><p>回顾上一节内容，我们使用普通单向链表来实现队列，因为它可以方便地删除头节点（对应出队操作）和在尾节点后添加新节点（对应入队操作）。</p><p>对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个对称方向的操作。为此，我们采用“双向链表”作为双向队列的底层数据结构。</p><p>如下图所示，我们将双向链表的头节点和尾节点视为双向队列的队首和队尾，同时实现在两端添加和删除节点的功能。</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">LinkedListDeque</button><button type="button" class="tab">push_last()</button><button type="button" class="tab">push_first()</button><button type="button" class="tab">pop_last()</button><button type="button" class="tab">pop_first()</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/a25b461a/linkedlist_deque_step1.png" alt="基于链表实现双向队列的入队出队操作"></p></div><div class="tab-item-content"><p><img src="/posts/a25b461a/linkedlist_deque_step2_push_last.png" alt="linkedlist_deque_push_last"></p></div><div class="tab-item-content"><p><img src="/posts/a25b461a/linkedlist_deque_step3_push_first.png" alt="linkedlist_deque_push_first"></p></div><div class="tab-item-content"><p><img src="/posts/a25b461a/linkedlist_deque_step4_pop_last.png" alt="linkedlist_deque_pop_last"></p></div><div class="tab-item-content"><p><img src="/posts/a25b461a/linkedlist_deque_step5_pop_first.png" alt="linkedlist_deque_pop_first"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>实现代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双向链表节点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.val: <span class="built_in">int</span> = val</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span>: ListNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 后继节点引用</span></span><br><span class="line">        <span class="variable language_">self</span>.prev: ListNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 前驱节点引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListDeque</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于双向链表实现的双向队列&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._front: ListNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 头节点 front</span></span><br><span class="line">        <span class="variable language_">self</span>._rear: ListNode | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 尾节点 rear</span></span><br><span class="line">        <span class="variable language_">self</span>._size: <span class="built_in">int</span> = <span class="number">0</span>  <span class="comment"># 双向队列的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取双向队列的长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断双向队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, num: <span class="built_in">int</span>, is_front: <span class="built_in">bool</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;入队操作&quot;&quot;&quot;</span></span><br><span class="line">        node = ListNode(num)</span><br><span class="line">        <span class="comment"># 若链表为空，则令 front 和 rear 都指向 node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="variable language_">self</span>._front = <span class="variable language_">self</span>._rear = node</span><br><span class="line">        <span class="comment"># 队首入队操作</span></span><br><span class="line">        <span class="keyword">elif</span> is_front:</span><br><span class="line">            <span class="comment"># 将 node 添加至链表头部</span></span><br><span class="line">            <span class="variable language_">self</span>._front.prev = node</span><br><span class="line">            node.<span class="built_in">next</span> = <span class="variable language_">self</span>._front</span><br><span class="line">            <span class="variable language_">self</span>._front = node  <span class="comment"># 更新头节点</span></span><br><span class="line">        <span class="comment"># 队尾入队操作</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将 node 添加至链表尾部</span></span><br><span class="line">            <span class="variable language_">self</span>._rear.<span class="built_in">next</span> = node</span><br><span class="line">            node.prev = <span class="variable language_">self</span>._rear</span><br><span class="line">            <span class="variable language_">self</span>._rear = node  <span class="comment"># 更新尾节点</span></span><br><span class="line">        <span class="variable language_">self</span>._size += <span class="number">1</span>  <span class="comment"># 更新队列长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_first</span>(<span class="params">self, num: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队首入队&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.push(num, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_last</span>(<span class="params">self, num: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队尾入队&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.push(num, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, is_front: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;出队操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;双向队列为空&quot;</span>)</span><br><span class="line">        <span class="comment"># 队首出队操作</span></span><br><span class="line">        <span class="keyword">if</span> is_front:</span><br><span class="line">            val: <span class="built_in">int</span> = <span class="variable language_">self</span>._front.val  <span class="comment"># 暂存头节点值</span></span><br><span class="line">            <span class="comment"># 删除头节点</span></span><br><span class="line">            fnext: ListNode | <span class="literal">None</span> = <span class="variable language_">self</span>._front.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fnext != <span class="literal">None</span>:</span><br><span class="line">                fnext.prev = <span class="literal">None</span></span><br><span class="line">                <span class="variable language_">self</span>._front.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="variable language_">self</span>._front = fnext  <span class="comment"># 更新头节点</span></span><br><span class="line">        <span class="comment"># 队尾出队操作</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            val: <span class="built_in">int</span> = <span class="variable language_">self</span>._rear.val  <span class="comment"># 暂存尾节点值</span></span><br><span class="line">            <span class="comment"># 删除尾节点</span></span><br><span class="line">            rprev: ListNode | <span class="literal">None</span> = <span class="variable language_">self</span>._rear.prev</span><br><span class="line">            <span class="keyword">if</span> rprev != <span class="literal">None</span>:</span><br><span class="line">                rprev.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                <span class="variable language_">self</span>._rear.prev = <span class="literal">None</span></span><br><span class="line">            <span class="variable language_">self</span>._rear = rprev  <span class="comment"># 更新尾节点</span></span><br><span class="line">        <span class="variable language_">self</span>._size -= <span class="number">1</span>  <span class="comment"># 更新队列长度</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop_first</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队首出队&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.pop(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop_last</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队尾出队&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.pop(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek_first</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;访问队首元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;双向队列为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._front.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek_last</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;访问队尾元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;双向队列为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._rear.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_array</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回数组用于打印&quot;&quot;&quot;</span></span><br><span class="line">        node = <span class="variable language_">self</span>._front</span><br><span class="line">        res = [<span class="number">0</span>] * <span class="variable language_">self</span>.size()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.size()):</span><br><span class="line">            res[i] = node.val</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化双向队列</span></span><br><span class="line">    deque = LinkedListDeque()</span><br><span class="line">    deque.push_last(<span class="number">3</span>)</span><br><span class="line">    deque.push_last(<span class="number">2</span>)</span><br><span class="line">    deque.push_last(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;双向队列 deque =&quot;</span>, deque.to_array())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问元素</span></span><br><span class="line">    peek_first: <span class="built_in">int</span> = deque.peek_first()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;队首元素 peek_first =&quot;</span>, peek_first)</span><br><span class="line">    peek_last: <span class="built_in">int</span> = deque.peek_last()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;队尾元素 peek_last =&quot;</span>, peek_last)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 元素入队</span></span><br><span class="line">    deque.push_last(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;元素 4 队尾入队后 deque =&quot;</span>, deque.to_array())</span><br><span class="line">    deque.push_first(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;元素 1 队首入队后 deque =&quot;</span>, deque.to_array())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 元素出队</span></span><br><span class="line">    pop_last: <span class="built_in">int</span> = deque.pop_last()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;队尾出队元素 =&quot;</span>, pop_last, <span class="string">&quot;，队尾出队后 deque =&quot;</span>, deque.to_array())</span><br><span class="line">    pop_first: <span class="built_in">int</span> = deque.pop_first()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;队首出队元素 =&quot;</span>, pop_first, <span class="string">&quot;，队首出队后 deque =&quot;</span>, deque.to_array())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取双向队列的长度</span></span><br><span class="line">    size: <span class="built_in">int</span> = deque.size()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;双向队列长度 size =&quot;</span>, size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断双向队列是否为空</span></span><br><span class="line">    is_empty: <span class="built_in">bool</span> = deque.is_empty()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;双向队列是否为空 =&quot;</span>, is_empty)</span><br></pre></td></tr></table></figure><h3 id="基于数组的实现">基于数组的实现</h3><p>如下图所示，与基于数组实现队列类似，我们也可以使用环形数组来实现双向队列。<br><strong>基于数组实现双向队列的入队出队操作</strong></p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">ArrayDeque</button><button type="button" class="tab">push_last()</button><button type="button" class="tab">push_first()</button><button type="button" class="tab">pop_last()</button><button type="button" class="tab">pop_first()</button></div><div class="tab-contents"><div class="tab-item-content active"><p><img src="/posts/a25b461a/array_deque_step1.png" alt="基于数组实现双向队列的入队出队操作"></p></div><div class="tab-item-content"><p><img src="/posts/a25b461a/array_deque_step2_push_last.png" alt="array_deque_push_last"></p></div><div class="tab-item-content"><p><img src="/posts/a25b461a/array_deque_step3_push_first.png" alt="array_deque_push_first"></p></div><div class="tab-item-content"><p><img src="/posts/a25b461a/array_deque_step4_pop_last.png" alt="array_deque_pop_last"></p></div><div class="tab-item-content"><p><img src="/posts/a25b461a/array_deque_step5_pop_first.png" alt="array_deque_pop_first"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>在队列的实现基础上，仅需增加“队首入队”和“队尾出队”的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayDeque</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于环形数组实现的双向队列&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构造方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._nums: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">0</span>] * capacity</span><br><span class="line">        <span class="variable language_">self</span>._front: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>._size: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">capacity</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取双向队列的容量&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取双向队列的长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断双向队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算环形数组索引&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 通过取余操作实现数组首尾相连</span></span><br><span class="line">        <span class="comment"># 当 i 越过数组尾部后，回到头部</span></span><br><span class="line">        <span class="comment"># 当 i 越过数组头部后，回到尾部</span></span><br><span class="line">        <span class="keyword">return</span> (i + <span class="variable language_">self</span>.capacity()) % <span class="variable language_">self</span>.capacity()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_first</span>(<span class="params">self, num: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队首入队&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._size == <span class="variable language_">self</span>.capacity():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;双向队列已满&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 队首指针向左移动一位</span></span><br><span class="line">        <span class="comment"># 通过取余操作实现 front 越过数组头部后回到尾部</span></span><br><span class="line">        <span class="variable language_">self</span>._front = <span class="variable language_">self</span>.index(<span class="variable language_">self</span>._front - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 将 num 添加至队首</span></span><br><span class="line">        <span class="variable language_">self</span>._nums[<span class="variable language_">self</span>._front] = num</span><br><span class="line">        <span class="variable language_">self</span>._size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_last</span>(<span class="params">self, num: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队尾入队&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._size == <span class="variable language_">self</span>.capacity():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;双向队列已满&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">        rear = <span class="variable language_">self</span>.index(<span class="variable language_">self</span>._front + <span class="variable language_">self</span>._size)</span><br><span class="line">        <span class="comment"># 将 num 添加至队尾</span></span><br><span class="line">        <span class="variable language_">self</span>._nums[rear] = num</span><br><span class="line">        <span class="variable language_">self</span>._size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop_first</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队首出队&quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="variable language_">self</span>.peek_first()</span><br><span class="line">        <span class="comment"># 队首指针向后移动一位</span></span><br><span class="line">        <span class="variable language_">self</span>._front = <span class="variable language_">self</span>.index(<span class="variable language_">self</span>._front + <span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>._size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop_last</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;队尾出队&quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="variable language_">self</span>.peek_last()</span><br><span class="line">        <span class="variable language_">self</span>._size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek_first</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;访问队首元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;双向队列为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._nums[<span class="variable language_">self</span>._front]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek_last</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;访问队尾元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;双向队列为空&quot;</span>)</span><br><span class="line">        <span class="comment"># 计算尾元素索引</span></span><br><span class="line">        last = <span class="variable language_">self</span>.index(<span class="variable language_">self</span>._front + <span class="variable language_">self</span>._size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._nums[last]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_array</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回数组用于打印&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>._size):</span><br><span class="line">            res.append(<span class="variable language_">self</span>._nums[<span class="variable language_">self</span>.index(<span class="variable language_">self</span>._front + i)])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Driver Code&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化双向队列</span></span><br><span class="line">    deque = ArrayDeque(<span class="number">10</span>)</span><br><span class="line">    deque.push_last(<span class="number">3</span>)</span><br><span class="line">    deque.push_last(<span class="number">2</span>)</span><br><span class="line">    deque.push_last(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;双向队列 deque =&quot;</span>, deque.to_array())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问元素</span></span><br><span class="line">    peek_first: <span class="built_in">int</span> = deque.peek_first()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;队首元素 peek_first =&quot;</span>, peek_first)</span><br><span class="line">    peek_last: <span class="built_in">int</span> = deque.peek_last()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;队尾元素 peek_last =&quot;</span>, peek_last)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 元素入队</span></span><br><span class="line">    deque.push_last(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;元素 4 队尾入队后 deque =&quot;</span>, deque.to_array())</span><br><span class="line">    deque.push_first(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;元素 1 队首入队后 deque =&quot;</span>, deque.to_array())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 元素出队</span></span><br><span class="line">    pop_last: <span class="built_in">int</span> = deque.pop_last()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;队尾出队元素 =&quot;</span>, pop_last, <span class="string">&quot;，队尾出队后 deque =&quot;</span>, deque.to_array())</span><br><span class="line">    pop_first: <span class="built_in">int</span> = deque.pop_first()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;队首出队元素 =&quot;</span>, pop_first, <span class="string">&quot;，队首出队后 deque =&quot;</span>, deque.to_array())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取双向队列的长度</span></span><br><span class="line">    size: <span class="built_in">int</span> = deque.size()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;双向队列长度 size =&quot;</span>, size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断双向队列是否为空</span></span><br><span class="line">    is_empty: <span class="built_in">bool</span> = deque.is_empty()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;双向队列是否为空 =&quot;</span>, is_empty)</span><br></pre></td></tr></table></figure><h2 id="双向队列应用">双向队列应用</h2><p>双向队列兼具栈与队列的逻辑，<strong>因此它可以实现这两者的所有应用场景，同时提供更高的自由度</strong>。</p><p>我们知道，软件的“撤销”功能通常使用栈来实现：系统将每次更改操作 <code>push</code> 到栈中，然后通过 <code>pop</code> 实现撤销。然而，考虑到系统资源的限制，软件通常会限制撤销的步数（例如仅允许保存 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50</span></span></span></span> 步）。当栈的长度超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50</span></span></span></span> 时，软件需要在栈底（队首）执行删除操作。<strong>但栈无法实现该功能，此时就需要使用双向队列来替代栈</strong>。请注意，“撤销”的核心逻辑仍然遵循栈的先入后出原则，只是双向队列能够更加灵活地实现一些额外逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;双向队列&lt;/h1&gt;
&lt;p&gt;在队列中，我们仅能删除头部元素或在尾部添加元素。如下图所示，&lt;u&gt;双向队列（double-ended queue）&lt;/u&gt;提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/a25b46</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="栈与队列" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
    
    <category term="队列" scheme="https://chaoleweisi.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列——小结</title>
    <link href="https://chaoleweisi.github.io/posts/76462b53/"/>
    <id>https://chaoleweisi.github.io/posts/76462b53/</id>
    <published>2024-10-13T03:20:14.000Z</published>
    <updated>2024-10-14T06:26:34.679Z</updated>
    
    <content type="html"><![CDATA[<h1>小结</h1><h3 id="重点回顾">重点回顾</h3><ul><li>栈是一种遵循先入后出原则的数据结构，可通过数组或链表来实现。</li><li>在时间效率方面，栈的数组实现具有较高的平均效率，但在扩容过程中，单次入栈操作的时间复杂度会劣化至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。相比之下，栈的链表实现具有更为稳定的效率表现。</li><li>在空间效率方面，栈的数组实现可能导致一定程度的空间浪费。但需要注意的是，链表节点所占用的内存空间比数组元素更大。</li><li>队列是一种遵循先入先出原则的数据结构，同样可以通过数组或链表来实现。在时间效率和空间效率的对比上，队列的结论与前述栈的结论相似。</li><li>双向队列是一种具有更高自由度的队列，它允许在两端进行元素的添加和删除操作。</li></ul><h3 id="Q-A">Q &amp; A</h3><p><strong>Q</strong>：浏览器的前进后退是否是双向链表实现？</p><p>浏览器的前进后退功能本质上是“栈”的体现。当用户访问一个新页面时，该页面会被添加到栈顶；当用户点击后退按钮时，该页面会从栈顶弹出。使用双向队列可以方便地实现一些额外操作，这个在“双向队列”章节有提到。</p><p><strong>Q</strong>：在出栈后，是否需要释放出栈节点的内存？</p><p>如果后续仍需要使用弹出节点，则不需要释放内存。若之后不需要用到，<code>Java</code> 和 <code>Python</code> 等语言拥有自动垃圾回收机制，因此不需要手动释放内存；在 <code>C</code> 和 <code>C++</code> 中需要手动释放内存。</p><p><strong>Q</strong>：双向队列像是两个栈拼接在了一起，它的用途是什么？</p><p>双向队列就像是栈和队列的组合或两个栈拼在了一起。它表现的是栈 + 队列的逻辑，因此可以实现栈与队列的所有应用，并且更加灵活。</p><p><strong>Q</strong>：撤销（undo）和反撤销（redo）具体是如何实现的？</p><p>使用两个栈，栈 <code>A</code> 用于撤销，栈 <code>B</code> 用于反撤销。</p><ol><li>每当用户执行一个操作，将这个操作压入栈 <code>A</code> ，并清空栈 <code>B</code> 。</li><li>当用户执行“撤销”时，从栈 <code>A</code> 中弹出最近的操作，并将其压入栈 <code>B</code> 。</li><li>当用户执行“反撤销”时，从栈 <code>B</code> 中弹出最近的操作，并将其压入栈 <code>A</code> 。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;小结&lt;/h1&gt;
&lt;h3 id=&quot;重点回顾&quot;&gt;重点回顾&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;栈是一种遵循先入后出原则的数据结构，可通过数组或链表来实现。&lt;/li&gt;
&lt;li&gt;在时间效率方面，栈的数组实现具有较高的平均效率，但在扩容过程中，单次入栈操作的时间复杂度会劣化至 &lt;span </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="栈与队列" scheme="https://chaoleweisi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
    
    <category term="总结" scheme="https://chaoleweisi.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
